[["index.html", "Einführung in R 1 Über dieses Buch", " Einführung in R Anna-Lena Schubert, Jan Goettmann, José Carlos García Alanis, Meike Steinhilber, Cordula Hunt, Florian Kobylka 2021-10-14 1 Über dieses Buch This is yet another test "],["einführung.html", "2 Einführung 2.1 Installation 2.2 Erste Schritte 2.3 Das R-Skript 2.4 Struktur des Skripts 2.5 Pakete 2.6 Working Directory", " 2 Einführung 2.1 Installation Um R nutzen zu können, müssen Sie sich sowohl R als auch R-Studio installieren. R ist eine Open-Source-Software, die zur Datenanalyse genutzt wird. Die große Stärke von R in der Verfügbarkeit zahlreicher Zusatzfunktionen, in Form sogenannter Packages. Entwickler:innen überall auf der Welt bieten Packages fals Lösungen für die unterschiedlichsten Probleme an, von der Datenaufbereitung über APA-formatierten Tabellen bis hin zu zahlreichen statistischen Analysen. Laden Sie sich R unter dem folgenden Link herunter und installieren Sie sich das Programm auf Ihrem PC/Laptop: https://cran.r-project.org/ Außerdem benötigen Sie noch R-Studio. R-Studio ist eine „integrierte Entwicklungsumgebung“ (engl: integrated development environment; IDE), die es deutlich einfacher macht, mit R zu arbeiten. Installieren Sie sich daher auch R-Studio auf Ihrem PC/Laptop, indem Sie folgendem Link folgen: https://www.rstudio.com/products/rstudio/download/#download 2.2 Erste Schritte Nachdem Sie R und R-Studio installiert haben, können Sie Ihre ersten Schritte in R machen. Öffnen Sie dazu R-Studio und geben Sie etwas in das Feld “Konsole” (oder “Console”) ein. Im Normalfall finden Sie die Konsole in der Anzeige auf der linken Seite (ggfs. befindet sich die Konsole auch links unten). Sie erkennen die Konsole daran, dass die Zeile, in die Sie etwas eingeben können, mit &gt; beginnt. Diese Klammer fordert Sie auf, R-Code einzugeben! Geben Sie Folgendes in die Konsole ein: &gt; &quot;Hallo R!&quot; Wenn folgende Ausgabe erscheint, hat die Installation funktioniert: ## [1] &quot;Hallo R!&quot; Sie können auch Zahlen in die Konsole eingeben: 42 ## [1] 42 Jetzt können Sie R schon als einfachen Taschenrechner benutzen! Addition: 3+2 ## [1] 5 Subtraktion: 3-2 ## [1] 1 Multiplikation: 3*2 ## [1] 6 Division: 3/2 ## [1] 1.5 Beachten Sie dabei, dass Sie auch Klammern setzen können: (3+2)*5 ## [1] 25 2.3 Das R-Skript In der Regel werden Sie Ihre Analysen nicht direkt in die Konsole eingeben, sondern ein Skript schreiben, in dem Sie Ihre Analysen dokumentieren. Dieses Skript dokumentiert Ihre Analysen, was den großen Vorteil hat, dass Ihre Analysen dadurch reproduzierbar werden. Wenn Sie Daten aufbereiten oder analysieren und dabei unterbrochen werden, können Sie sich - auch noch Tage oder Wochen später - einfach wieder an das Skript setzen, die bisherigen Analyseschritte erneut ausführen und dort weitermachen. So können Sie Ihre Analysen auch mit anderen Studierenden oder Lehrenden, die ein Projekt betreuen, teilen. Viele Forschende laden ihre R-Skripte regelmäßig ins Open Science Framework (OSF) hoch, wenn sie Artikel zur Begutachtung einreichen, damit andere ihren Code und ihre Analysen auf Fehler überprüfen und nachvollziehen können. Um ein solches Skript zu erstellen, nutzen wir den in R-Studio verfügbaren Texteditor. Sie können ein neues Skript unter „Datei \\(\\to\\) NeueDatei \\(\\to\\) R Skript“ („File \\(\\to\\) New File \\(\\to\\) R Script“ öffnen. Skripte, die R-Code enthalten, speichern wir mit der Dateiendung „.r“ oder „.R“ ab. Das Praktische: Wenn Sie Code im Skript schreiben, können Sie diesen Code direkt ausführen. Wenn sich Ihr Cursor in einer Zeile befindet, in der Code steht, können Sie STRG-Enter drücken (oder oben auf das Run-Symbol klicken), um diese Zeile auszuführen. Wenn Sie einen Teil des Skripts markieren, wird nur genau dieser Teil ausgeführt, wenn Sie STRG-Enter drücken. Das Ergebnis wird Ihnen wie gewohnt in der Konsole angezeigt. 2.4 Struktur des Skripts Nichts ist wichtiger als gute Organisation! Damit Sie sich auch später noch daran erinnern, welche Analysen Sie durchgeführt haben, können (und sollten) Sie sich Kommentare ins Skript schreiben. In R wird # benutzt, um Code zu kommentieren. Wenn Sie # vor Code setzen, wird dieser Code beim Ausführen einfach ignoriert! So können Sie sich ganze Abschnitte dazu notieren, welche Analysen Sie gemacht haben, was Kernbefunde waren, usw., ohne dass Sie Probleme beim Ausführen Ihres Skriptes bekommen. Sie sollten Ihren Code immer kommentieren, um sich auch später noch daran erinnern zu können, was Sie vor einiger Zeit geschrieben haben. # 3+2 # Nichts passiert - die Rechnung wurde nicht ausgeführt, weil sie auskommentiert ist Sie können Kommentare auch nutzen, um das Skript in Abschnitte zu gliedern. Wenn Sie hinter ein # noch ein - setzen, fügt der Editor einen logischen Abschnitt ein, den Sie ein- oder ausklappen können. Das ist insbesondere zur Strukturierung längerer Skripte enorm hilfreich. 2.5 Pakete Für R gibt es unzählige nützliche Pakete, die von Entwickler:innen auf der ganzen Welt weiterentwickelt werden. Auch an der JGU werden R-Pakete entwickelt! Diese Pakete erweitern das Grundprogramm und geben Ihnen Tools an die Hand, die Ihnen bei der Bearbeitung ganz konkreter Fragestellungen helfen können. Das Paket psych wurde von William Revelle entwickelt, um verschiedene Funktionen zu bündeln, die für verschiedene psychologische Fragestellungen nützlich sind. Installieren Sie das Paket mit der Funktion install.packages(). install.packages(&quot;psych&quot;) Sobald Sie das Paket installiert haben, müssen Sie es nur noch laden, um es nutzen zu können: library(psych) Und schon haben Sie Ihr erstes Paket installiert und geladen! Sobald Sie ein Paket auf Ihrem PC/Laptop installiert haben, können Sie es immer wieder verwenden. Beachten Sie aber unbedingt, dass Sie Pakete nach jedem Neustart von R neu einladen müssen. Wenn Sie keine Idee haben, welche Funktionen ein Paket umfasst und wofür es nützlich sein könnte, können Sie ganz einfach die Hilfe-Funktion nutzen, die Sie aufrufen können, indem Sie ein Fragezeichen vor den Paketnamen setzen. ?(psych) 2.6 Working Directory Wenn Sie in R arbeiten, arbeiten Sie immer in einem Verzeichnis - einem sog. “working directory”. Sie können sich Ihr aktuelles working directory mit dem Befehl ‘getwd()’ anzeigen lassen. getwd() ## [1] &quot;/Users/runner/work/R-Kurs-Buch/R-Kurs-Buch&quot; In der Regel werden Sie für jedes Projekt ein eigenes working directory anlegen, in dem Sie die Daten und Skripte speichern, die zu dem Projekt gehören. Um in das richtige Verzeichnis zu wechseln, können Sie den Befehl setwd() nutzen. Noch einfacher geht es per Mausklick über Session → Set Working Directory → Choose Directory. Tipp: Wenn Sie bereits ein Verzeichnis für Ihr Projekt angelegt und dort ein Skript gespeichert haben (wichtig: es muss unbedingt im Verzeichnis gespeichert sein!), können Sie mit folgendem Codeschnipsel ganz einfach ihr working directory dorthin legen, wo Ihr aktuelles Skript gespeichert ist. Das ist auch dann enorm praktisch, wenn Sie Ihre Skripte mit anderen austauschen! Dazu müssen Ihr allerdings zunächst das Paket “rstudioapi” installieren. install.packages(&quot;rstudioapi&quot;) setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) "],["erste-schritte-1.html", "3 Erste Schritte 3.1 Variablen 3.2 Vektoren 3.3 Auswahl von Vektorelementen 3.4 Logische Vergleiche", " 3 Erste Schritte 3.1 Variablen Sicherlich wollen Sie Ihre Daten nicht nur in der Konsole ausgeben lassen und bearbeiten, sondern auch in Variablen speichern. Variablen sind Bezeichnungen, mit deren Hilfe Sie auf gespeicherte Daten zugreifen. Sobald eine Variable definiert wurde, können Sie immer wieder darauf zugreifen. Variablen werden mit Hilfe des &lt;- Operators definiert. Sie können sich die Werte dieser Variablen ausgeben lassen, indem Sie die Variablennamen in der Konsole eingeben und Enter drücken. x ## [1] 2 Jetzt können Sie bereits erste Berechnungen mit Variablen durchführen: x+y ## [1] 5 x*y ## [1] 6 In R lassen sich sämtliche Objekte - nicht nur einzelne Zahlen, sondern auch Datentabellen, Wortlisten oder sogar Ergebnisse komplizierter Analysen - in Variablen speichern. Der Workflow ist so ausgelegt, dass Sie Ergebnisse einer Analyse in einer Variable speichern und von dort aus weiterverarbeiten können, z.B. um APA-konforme Tabellen oder Grafiken zu erstellen oder sich Effektstärkemaße ausgeben zu lassen. Im weiteren Verlauf des Kurses lernen Sie andere Datentypen kennen, die in Variablen gespeichert werden können. Achtung: Wenn Sie eine Berechnung mit einer Variable durchführen und das Ergebnis dieser Berechnung speichern möchten, müssen Sie es wieder eine Variable zuweisen - es wird nicht automatisch gespeichert! z &lt;- x*10 Wenn Sie sich jetzt x und z ausgeben lassen, sehen Sie, dass sich nichts an x geändert hat - das Ergebnis der Berechnung wurde nicht abgespeichert. In der Variable z hingegen sehen Sie das Ergebnis Ihrer Berechnung. x ## [1] 2 z ## [1] 20 x, y und z sind denkbar schlechte Variablennamen! Gute Variablennamen sprechen, d.h. dass der Name eine Variable verrät, was sich “in” dieser Variable verbirgt. Deswegen sollten Sie sich immer bemühen, möglichst klare und eindeutige Variablennamen zu vergeben. # Beispiele für gute Variablennamen durchschnittliches_Alter &lt;- 23 MW_Alter &lt;- 23 durchschnittliches_Evaluationsergebnis_KursA &lt;- 2 MW_Evaluationsergebnis_KursA &lt;- 2 Scheuen Sie sich nicht vor langen Variablennamen! Je besser und klarer Sie Ihre Variablen definieren, desto einfacher wird es sowohl Ihnen als auch anderen fallen, Ihren Code nachzuvollziehen. Besonders einfach lesbar sind längere Variablennamen, wenn Sie unterschiedliche Elemente des Variablennamens mit einem Unterstrich trennen. Diese Konvention wird auch in diesem Kurs verwendet. 3.2 Vektoren Jede Spalte eines Datensatzes ist ein Vektor. In einem Vektor befinden sich mehrere Elemente eines Datentyps, also z.B. mehrere Zahlen oder mehrere Wörter. Vektoren werden mit Hilfe des “combine”-Operators c erstellt. Vektor_numeric &lt;- c(1, 2, 3, 4, 5, 6:10) Mit jedem Datentyp können Sie unterschiedliche Operationen durchführen. Um sich den Datentyp eines Vektors anzeigen zu lassen, können Sie die Funktion mode verwenden. mode(Vektor_numeric) ## [1] &quot;numeric&quot; 3.2.1 Datentyp numeric Mit Vektoren vom Typ numeric können Sie verschiedene mathematische Operationen durchführen. Sie können diese Vektoren addieren, multiplizieren, usw. Wenn Sie eine Operation wie *2 auf den Vektor anwenden, wird diese Operation auf alle Elemente des Vektors angewendet. Vektor_numeric*2 ## [1] 2 4 6 8 10 12 14 16 18 20 Wenn Sie hingegen zwei gleich lange Vektoren haben, wird jedes i-te Element des ersten Vektors mit dem i-ten Element des zweiten Vektors verrechnet. Das Element an Position 1 im einen Vektor wird dann mit dem Element an Position 1 im anderen Vektor gepaart, das Element an Position 2 im einen Vektor mit dem Element an Position 2 im anderen Vektor – und so weiter. punkte_MC_Fragen &lt;- c(5, 2, 2, 4, 3, 2, 1, 0, 1, 4) punkte_offene_Fragen &lt;- c(3, 4, 5, 0, 2, 3, 1, 3, 5, 1) klausurergebnis &lt;- punkte_MC_Fragen + punkte_offene_Fragen klausurergebnis ## [1] 8 6 7 4 5 5 2 3 6 5 3.2.2 Datentyp character Wenn Sie in einer Variable Text abspeichern wollen, erschaffen Sie eine Variable vom Datentyp character. Test wird mit doppelten oder einfachen Anführungszeichen angegeben: &quot;Alpha&quot; ## [1] &quot;Alpha&quot; &#39;Beta&#39; ## [1] &quot;Beta&quot; Vektor_character &lt;- c(&quot;Lea&quot;, &quot;Luke&quot;, &quot;Han&quot;, &quot;Chewy&quot;) mode(Vektor_character) ## [1] &quot;character&quot; Mit Vektoren des Typs character können Sie natürlich keine mathematischen Operationen durchführen. Sie sind aber nützlich, um bestimmte Daten zu kodieren, wie bspw. das Geschlecht oder das Studienfach von Versuchspersonen. Geschlecht &lt;- c(&quot;männlich&quot;, &quot;weiblich&quot;, &quot;weiblich&quot;, &quot;divers&quot;, &quot;weiblich&quot;) Studienfach &lt;- c(&quot;Psychologie&quot;, &quot;Medizin&quot;, &quot;Informatik&quot;, &quot;Sportwissenschaft&quot;, &quot;Biologie&quot;) 3.2.3 Datentyp logical Der Datentyp logical kodiert nur binäre Informationen - diese sind entweder TRUE oder FALSE. TRUE ## [1] TRUE FALSE ## [1] FALSE Vektor_logical &lt;- c(TRUE, TRUE, FALSE, TRUE) mode(Vektor_logical) ## [1] &quot;logical&quot; Dabei werden TRUE und FALSE als logische Bedingungen interpretiert, die erfüllt oder nicht erfüllt sein können. Vektoren dieses Datentyps sind für die Datenaufbereitung unglaublich nützlich! Mit Hilfe eines Vektors vom Typ logical können sie beispielsweise kodieren, welche Versuchspersonen die Studie vollständig abgeschlossen haben oder ob einzelne Beobachtungen Ausreißer darstellen. Sie werden diesen Datentyp häufig benötigen, wenn Sie in Datentabellen einzelne Fälle auswählen oder Versuchspersonen ausschließen möchte. Hierbei wird dann jeweils im Einzelfall überprüft, welche Fälle eine gewünschte Bedingung erfüllen (z.B. maximal 30 Minuten zur Bearbeitung eines Tests gebraucht haben) und daher in den weiteren Analysen eingeschlossen werden. # Hier wird festgehalten, welche Versuchspersonen (id) die Studie # vollständig abgeschlossen haben (Studie_abgeschlossen) id &lt;- c(1:10) Studie_abgeschlossen &lt;- c(TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE) Mit logischen Werten kann man die logischen Operationen UND (&amp;), ODER (| ) und NICHT (! ) umsetzen. UND und ODER verknüpfen jeweils zwei logische Bedingungen (sprich: zwei logische Werte, also TRUE/FALSE) miteinander und geben selbst einen logischen Wert zurück. Die Verknüpfung UND ergibt dann TRUE, wenn beide Bedingungen erfüllt sind, d.h. nur wenn die erste und die zweite Bedingung jeweils TRUE sind. ## Logisches UND TRUE &amp; TRUE ## [1] TRUE TRUE &amp; FALSE ## [1] FALSE FALSE &amp; FALSE ## [1] FALSE einen logischen Wert zurück. Die Verknüpfung ODER ergibt dann TRUE, wenn mindestens eine der beiden Bedingungen erfüllt ist, d.h. wenn die erste oder die zweite Bedingung oder beide Bedingungen TRUE sind. Ganz wichtig: ODER gibt auch dann TRUE aus, wenn beide Bedingungen erfüllt sind! ## Logisches ODER TRUE | TRUE ## [1] TRUE TRUE | FALSE ## [1] TRUE FALSE | FALSE ## [1] FALSE Das logische NICHT invertiert eine logische Variable: Aus TRUE wird FALSE und umgekehrt. Das ist hier noch etwas abstrakt, wird aber später in den Kapiteln zur Datenaufbereitung noch klarer. ## Logisches NICHT !TRUE ## [1] FALSE !FALSE ## [1] TRUE 3.2.4 Datentyp factor Variablen vom Datentyp factor sind nützlich, um kategoriale Variablen zu kodieren. Dabei wird zunächst ein Vektor vom Typ ‘numeric’ erstellt. Den einzelnen Werten dieses numerischen Vektors werden dann kategoriale Bezeichnungen zugewiesen. Bedingung &lt;- c (0, 1, 1, 0, 1, 0, 0, 1) Vektor_factor &lt;- factor(x = Bedingung, levels = c(0,1), labels = c(&quot;Kontrollgruppe&quot;, &quot;Experimentalgruppe&quot;)) Vektor_factor ## [1] Kontrollgruppe Experimentalgruppe Experimentalgruppe Kontrollgruppe ## [5] Experimentalgruppe Kontrollgruppe Kontrollgruppe Experimentalgruppe ## Levels: Kontrollgruppe Experimentalgruppe mode(Vektor_factor) ## [1] &quot;numeric&quot; Dazu verwenden Sie die Funktion factor. Dieser Funktion übergeben Sie den numerischen Vektor Bedingung und definieren anschließend die Stufen des Faktors mit Hilfe des Argument levels (hier 0 und 1) sowie die Bezeichnungen mit Hilfe des Argument labels (hier Kontrollgruppe und Experimentalgruppe). Es ist immer sinnvoll, Variablen als Faktoren zu definieren, wenn sie endliche Ausprägungen haben. Experimentelle Bedingungen, Messzeitpunkte oder das Geschlecht von Versuchspersonen sind typische Kandidaten, die als Vektoren vom Typ factor gespeichert werden. Der Vorteil dieses Variablentyps besteht darin, dass Sie dort die Zuordnung von numerischen zu verbalen Bezeichnungen direkt vornehmen können und nachher nicht mehr nachschlagen müssen, ob “0” oder “1” nun die Experimentalgruppe kodiert. Spätestens bei der Auswertung Ihrer Daten sollten Sie solche Variablen also immer als factor rekodieren. Achtung: Sie können mit Faktoren keine mathematischen Operationen durchführen, auch wenn ihnen eigentlich numerische Kodierungen zugrunde liegen. In R werden Vektoren vom Variablentyp factor diesbezüglich ebenso wie Vektoren vom Variablentyp character behandelt. 3.2.5 Datentyp NA Ein Vektor besteht in der Regel nicht nur aus Variablen vom Datentyp NA. In echten Datensätzen werden Sie aber immer mal wieder fehlende Daten haben. Diese werden in R als NA kodiert. alter &lt;- c (21, 25, 29, 24, NA, 19, 23, 24, 20) Achtung: In anderer Statistiksoftware wie z.B. SPSS hat sich die Konvention entwickelt, fehlende Werte nicht mit “NA”, sondern mit bestimmten nicht beobachtbaren numerischen Werten wie “-9” oder “-99” zu beschreiben. Wenn Sie mit einem solchen Datensatz arbeiten, der zuvor in einer anderen Statistiksoftware bearbeitet wurde, sollten Sie immer überprüfen, ob fehlende Werte anhand solcher numerischen Werte kodiert sind und diese als “NA” rekodieren. 3.3 Auswahl von Vektorelementen Sie können auf einzelne Elemente eines Vektor zugreifen, indem Sie den Operator [] verwenden. In die eckigen Klammern wird die Position des Elements eingefügt, das Sie auswählen möchte. Dieses Vorgehen wird Indizierung genannt. daten &lt;- c (3, 7, 9, 0, 1, 1, 4, 5) daten[3] ## [1] 9 # Hier wird das dritte Element ausgewählt Sie können auch eine sogenannte Negativindizierung durchführen, d.h. im Index festhalten, welches Element Sie nicht auswählen möchten. daten[-3] ## [1] 3 7 0 1 1 4 5 # Hier werden alle Elemente außer des dritten ausgewählt Selbstverständlich können Sie auch gleich mehrere Elemente auswählen. Wenn Sie z.B. alles vom zweiten bis fünften Element auswählen wollen, können Sie das im Index so vermerken: [2:5]. Ganz allgemein gilt: Die Zahl vor dem Doppelpunkt gibt an, wo die Indizierung beginnt, und die Zahl nach dem Doppelpunkt gibt an, wo die Indizierung endet. daten[2:5] ## [1] 7 9 0 1 # Hier werden die Elemente 2, 3, 4 und 5 ausgewählt Wenn Sie mehrere Elemente auswählen möchten, die nicht direkt nebeneinander stehen, müssen Sie diese mit dem “combine”-Operator c verknüpfen: daten[c(2, 7)] ## [1] 7 4 # Hier werden die Elemente 2 und 7 ausgewählt Die so ausgewählten Daten können Sie natürlich wieder in einer neuen Variable speichern: ausgewaehlte_daten &lt;- daten[c(2, 7)] 3.4 Logische Vergleiche Logische Vergleiche können genutzt werden, um bestimmte Fälle - z.B. einzelne Versuchspersonen - auszuwählen. Welche logischen Vergleich für einen Datentyp sinnvoll sind, hängt von diesem Datentyp ab. 3.4.1 Datentyp numeric Wenn Sie Daten vom Typ numeric haben, können Sie numerische Vergleiche durchführen. Sie können zum Beispiel überprüfen, welche Ihrer Versuchspersonen älter als 18 Jahre sind. Dazu verwenden Sie den logischen Operator &gt;=, den Sie als “größer oder gleich” interpretieren können (analog dazu liest sich &lt;= als “kleiner oder gleich”.) alter &lt;- c(20, 21, 24, 25, 32, 17, 65, 22) alter &gt;= 18 ## [1] TRUE TRUE TRUE TRUE TRUE FALSE TRUE TRUE Bei numerischen Vektoren können Sie folgende logischen Vergleiche durchführen: (a) gleich (==), (b) größer (&gt;), (c) kleiner (&lt;), (d) größer gleich (&gt;=), (e) kleiner gleich (&lt;=) oder (f) ungleich (!=). Wenn Sie einen logischen Vergleich mit einem gesamten Vektor durchführen, wird für jedes einzelne Element überprüft, ob es der logischen Bedingung entspricht (TRUE) oder nicht (FALSE). # Hier überprüfen wir, welche Versuchspersonen jünger als 18 Jahre sind alter &lt; 18 ## [1] FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE # Wir können auch überprüfen, welche Versuchspersonen genau 18 Jahre sind alter == 18 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 3.4.2 Datentyp character Vektoren vom Typ character lassen sich darauf überprüfen, ob diese identisch mit einer bestimmten Bedingung sind. # Hier wird überprüft, welche Versuchspersonen Psychologie studieren Studienfach &lt;- c(&quot;Psychologie&quot;, &quot;Medizin&quot;, &quot;Informatik&quot;, &quot;Sportwissenschaft&quot;, &quot;Biologie&quot;) Studienfach == &quot;Psychologie&quot; ## [1] TRUE FALSE FALSE FALSE FALSE 3.4.3 Datentyp factor Dieser logische Vergleich lässt sich auch mit Daten vom Typ factor durchführen. Bedingung &lt;- c (0, 1, 1, 0, 1, 0, 0, 1) Bedingung &lt;- factor(x = Bedingung, levels = c(0,1), labels = c(&quot;Kontrollgruppe&quot;, &quot;Experimentalgruppe&quot;)) # Hier wird überprüft, welche Versuchspersonen der Experimentalgruppe angehören Bedingung == &quot;Experimentalgruppe&quot; ## [1] FALSE TRUE TRUE FALSE TRUE FALSE FALSE TRUE 3.4.4 Rekodieren von Variablen mit Hilfe logischer Vergleich Sie werden logische Vergleiche häufig anwenden, um Daten zu rekodieren. Schauen Sie sich dazu die folgenden Beispiele an. Mit Hilfe logischer Vergleiche können Sie überprüfen, ob fehlende Werte nicht mit “NA”, sondern mit “-9” kodiert wurden, um diese anschließend zu rekodieren. Testwerte &lt;- c(80, 57, 93, 85, 72, 65, -9) Testwerte == -9 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE TRUE Sie können das Ergebnis dieses logischen Vergleichs nun nutzen, um alle Werte, die als -9 kodiert wurden, zu rekodieren. Dazu speichern Sie das Ergebnis des logischen Vergleichs einfach in einer neuen Variable ab. fehlende_Werte &lt;- Testwerte == -9 Im nächsten Schritt benutzen Sie die neue erstellte Variable vom Typ logical, um alle Werte des Vektors Testwerte, die den Wert “-9” haben, durch “NA” zu ersetzen. Testwerte[fehlende_Werte] &lt;- NA # Hier wurde der Werte -9 durch NA ersetzt: Testwerte ## [1] 80 57 93 85 72 65 NA Ganz ähnlich können Sie bei einem Reaktionszeitexperiment alle Trials entfernen, in denen Versuchspersonen sehr lange mit ihrer Reaktion gebraucht haben, d.h. in denen sie möglicherweise mit ihrer Aufmerksamkeit abgeschweift sind. # Als erstes werden 1000 Trials einer Versuchsperson simuliert RTs &lt;- rnorm(n = 1000, mean = 500, sd = 100) hist(RTs) # In diesem Vektor von Reaktionszeiten werden alle RTs, die länger als 700 ms sind, entfernt Ausreisser &lt;- RTs &gt; 700 RTs[Ausreisser] &lt;- NA hist(RTs) Für die ganz Eiligen: Sie können dies auch in einem einzigen Schritt durchführen, es ist dann aber fehleranfälliger. Dazu geben Sie den logischen Vergleich direkt als Index an: RTs &lt;- rnorm(n = 1000, mean = 500, sd = 100) # Hier wird der logische Vergleich direkt als Index von RTs genutzt. RTs[RTs &gt; 700] &lt;- NA Alternativ könnten Sie Extremwerte natürlich durch einen sinnvollen Maximalwert ersetzen. Beispielsweise lassen sich Reaktionszeiten, die länger als 700 ms sind, auf 700 ms “deckeln”. RTs &lt;- rnorm(n = 1000, mean = 500, sd = 100) # Hier wird der logische Vergleich direkt als Index von RTs genutzt. RTs[RTs &gt; 700] &lt;- 700 Sie können auch mehrere logische Vergleiche kombinieren. In Reaktionszeitexperimenten wollen Sie meist extrem langsame sowie extrem schnelle Durchgänge ausschließen, weil Sie nicht sicher sein können, ob die Versuchspersonen vorschnell reagiert haben (extrem schnelsl) oder mit ihren Gedanken nicht bei der Sache waren (extrem langsam). Dazu können Sie mehrere logische Vergleiche kombinieren. # Als erstes werden 1000 Trials einer Versuchsperson simuliert RTs &lt;- rnorm(n = 1000, mean = 500, sd = 100) # Dann werden untere und obere Grenzen als Variablen definiert. Dies hat den # Vorteil, dass Sie einfach diese Variablen im Code anpassen können, wenn Sie # die Kriterien zur Ausreißeranalyse anpassen möchten. untere_Grenze &lt;- 300 obere_Grenze &lt;- 700 # In diesem Vektor von Reaktionszeiten werden alle RTs, die schneller als 200 ms # oder länger als 700 ms sind, entfernt. Dazu wird der logische ODER-Operator # benötigt; es sollen solche Trials identifiziert werden, die &lt; 300 ms ODER # &gt; 700 ms sind. Ausreisser &lt;- (RTs &gt; obere_Grenze | RTs &lt; untere_Grenze) RTs[Ausreisser] &lt;- NA # Im Histogramm ist zu sehen, dass sowohl sehr schnelle als auch sehr langsame # Trials aus den Daten entfernt wurden. hist(RTs) "],["datenstruktur.html", "4 Datenstruktur 4.1 RMarkdown 4.2 Hilfe 4.3 Werte &amp; Vektoren 4.4 Der Workspace 4.5 Einfache Berechnungen 4.6 Matrizen 4.7 tidy Daten 4.8 data.frames (df) und tibbles (tib) 4.9 Einlesen und Speichern von Daten 4.10 Datensätze (dat) anschauen", " 4 Datenstruktur Thema Inhalte RMarkdown Titel, Chunks, knitten Hilfe help-Fenster, ?, #was passiert hier Werte, Vektoren &amp; Listen chr, num, log, c(), list(), typeof(), coercion, Abruf von Elementen, list(list()) Workspace rm(), Besen Berechnungen mit Values, Vektoren, Funktionen, z-Standardisierung Matrizen matrix(), Indizierung tidy Daten Zeilen: Beobachtungen, Spalten: Variablen tidyverse Installation und library (package) data.frame &amp; tibble Unterschiede, as.data.frame(), as_tibble(), $, [], Zugriff auf Elemente, Reihennamen, Faktoren Daten laden &amp; speichern Import per klick, read./_, sep=, dec=, .xlsx, .svs, write_csv() Daten anschauen View(), head(), str(), count() 4.1 RMarkdown Das R Markdown Skript ist ein besonderes Dateiformat für R Skripte. Es enthält Fließtext und eingebetteten R Code: Knittet man dies Skript mit dem Wollknäul Button (5.) in der oberen Leiste, integriert es den ausgeführten Code mit dem Fließtext und druckt ein übersichtliches Dokument (html, pdf, txt oder doc). Das ist praktisch um z.B. Auswertungsergebnisse zu präsentieren. Im Header werden Titel und Dokumententyp für das Ausgabe-Dokument festgelegt Die Code Blöcke (Chunks) sind mit je drei rückwärts gestellten Hochkommata (Backticks) am Anfang und Ende des Chunks eingerahmt. Werden sie vom R Markdown Skript als solche erkannt, wird auch die Hintergrundfarbe automatisch abgeändert. Im ersten Chunk sollten globale Chunk Optionen festgelegt, alle notwendigen Packages geladen und die Daten eingelesen werden. Den Fließtext kann man mit Überschriften (#) und Unterüberschriften (##) strukturieren, im Code kennzeichnet # Kommentare Zu Beginn eines Chunks muss man innerhalb einer geschwungenen Klammer spezifizieren(```{…}): Es ist möglich Code von anderen Programmiersprachen (z.B. Python oder TeX) einzubetten, standard ist r (optional) Nach einem Leerzeichen: Einzigartiger Chunk-Name (optional) Nach einem Komma: Befehle, um die Ausgabe des Chunks in das neue Dokument zu steuern: include = FALSE Weder Code noch Ergebnis erscheinen echo = FALSE Nur das Code-Ergebnis erscheint message = FALSE Nachrichten zum Code erscheinen nicht warning = FALSE Warnungenzum Code erscheinen nicht fig.cap = \"...\" Hiermit lassen sich Grafiken beschriften 4.2 Hilfe Sie merken, dass die Befehle und Funktionen zum Teil sehr spezifisch und Sie sich kaum alles behalten können. Am wichtigsten ist die Reihenfolge und Vollständigkeit der Zeichen: vergessen Sie ein Komma, ein Backtick oder eine Klammer zu, dann kann R den Code schon nicht interpretieren. Zum Glück erkennt R Studio das oft und weist einen darauf während des Codens mit einem roten x neben der Zeilennummer hin. Andernfalls dürfen Sie versuchen, die Fehlermeldung beim Ausführen zu verstehen. Wenn Sie den Namen einer Funktion oder eines Packages nicht direkt erinnern, können Sie den Anfang des Namens im Chunk oder in der Console eingeben, RStudio bietet einem nach einem kurzen Moment eine Liste möglicher Optionen an, aus der Sie wählen können. Haben Sie eine Funktion gewählt, können sie die Tab-Taste drücken und es werden die verschiedenen Funktionsargumente angezeigt, um die Funktion zu spezifizieren, was oft sehr hilfreich ist. Möchten Sie wissen, was eine Funktion macht oder in welcher Reihenfolge die Funktionsargumente eingegeben werden, können Sie ?FUN in die Console eintippen, wobei FUN Platzhalter für den Funktionsnamen ist. Alternativ können Sie im Help-tab unten rechts suchen. Die Dokumentation ist oft sehr ausführlich. Die Möglichkeit einschlägige Suchmaschinen im Internet zu verwenden ist fast zu trivial, um sie hier aufzuführen, oft werden Sie dabei auf StackOverflow weitergeleitet. Auf Englisch gestellte Fragen oder Probleme führen zu besseren Treffern. Noch trivialer ist es, im Skript des Kurses oder im eigenen Code nachzuschauen. Falls Sie gründlich nachlesen möchten, gibt es auch ganze Bücher, die einem eine Einführung in R geben: z.B. R Cookbook oder R for Data Science. 4.3 Werte &amp; Vektoren Datenformate in R sind von einfach zu komplex: Value, Vektor, matrix, (array), data.frame,tibble und list. Die kleinste Objekteinheit in R ist ein Value. Es gibt unterschiedliche Typen von Values: Text, bzw. Charakter (chr), manchmal auch String genannt, (komplexe Zahlen, cmplx) Nummer (num), bzw.double (ganze Zahlen, integer int genannt) logische Werte (logi), manchmal auch Boolean genannt fehlende Werte (NA), Not Available Sie weisen einem Objektnamen einen Wert per &lt;- zu (Shortkey:ALT&amp;-), der Datentyp des Values wird automatisch Rkannt. var1 &lt;- &quot;kreativ&quot; # typ chr var2 &lt;- 3.5 # typ num var3 &lt;- TRUE # typ logi Mit der Funktion typeof() können sie sich den Datentypen anzeigen lassen. Vektoren reihen Werten desselben Datentyps auf c(Wert1, Wert2, ...): vec1 &lt;- c(3, 6, 3.4) # c() kombiniert die Werte zu einem Vektor, der dem Namen zugewiesen wird Fassen Sie Werte von verschiedenen Typen zu einem Vektor zussammen, werden beide Werte zum Typen mit der kleineren Typenzahl umgewandelt (coercion). c(&quot;kreativ&quot;,3.5) # ich versuche ein `chr` und eine `num` zu einem Vektor zu kombinieren ## [1] &quot;kreativ&quot; &quot;3.5&quot; 3.5 wird in \"\" ausgegeben, die Nummer wurde zu Text. 4.3.1 Coercion (Umwandlung von Typen) Sie können den Datentypen auch per Funktion ändern, z.B. as.character(), as.double(): as.character(c(1, TRUE, &quot;abc&quot;, 4.1627)) # Verändert eine Reihe von Werten zum Typ chr ## [1] &quot;1&quot; &quot;TRUE&quot; &quot;abc&quot; &quot;4.1627&quot; as.double(c(2, TRUE, &quot;abc&quot;, 4.1627)) # Verändert die Werte zum Typ double, geht es nicht, erscheinen NAs ## Warning: NAs introduced by coercion ## [1] 2.0000 NA NA 4.1627 Coercion gibt es auch in Matrizen, Arrays (Mehrdimensionale Matrizen) und in Spaltenvektoren von Datensätzen (data.frames und tibbles). Nur Listen können verschiedene Datentypen und Elemente enthalten list(Element1, Element2, ...). Das geht soweit, dass Listen selbst Listen enthalten können. 4.3.2 Aufruf einzelner Elemente per Index: Um auf Elemente zuzugreifen, können Sie deren Indexnummer verwenden: vec_4 &lt;- c(1,3,3,7) #Definition des Vektors vec_4[2] #Abruf des zweiten Elements des Vektors ## [1] 3 Das geht sogar in verschachtelten Listen: mylist &lt;- list(list(1,&quot;a&quot;),c(2,3)) # Definiert eine Liste aus Liste &amp; Vector, die je aus 2 Elementen bestehen mylist[[1]][2] # Ruft Element 1 der äußeren Liste: (1,&quot;a&quot;), und davon Element 2 ab: &quot;a&quot; ## [[1]] ## [1] &quot;a&quot; Ich habe jetzt mehrere Variablen (Values, Vektoren, Listen) definiert, sie sind in meinem RStudio im Environment-tab oben rechts aufgetaucht. 4.4 Der Workspace Rechts oben im Fenster ist das Environment-tab. Hier sieht man alle im globale Workspace definierten Objekte (Datenstrukturen: Werte, Vektoren, Matrizen, Arrays, Listen, data.frames, tibbles; und Funktionen) aufgelistet: Per Doppelklick können Sie die Objekte jeweils einzeln oben links im extra Fenster (Datenansicht-tab ) anschauen. rm(Objektname) ist die Funktion zum Entfernen einzelner Objekte aus dem globalen Workspace. Das Besensymbol im Environment-tab oben rechts fegt den globalen Workspace leer. Es ist zu beachten, dass R Markdown beim knitten nicht auf den globalen Workspace zugreift, sondern einen eigenen Workspace aus dem Code in den Chunks erstellt. Beim Ausführen einzelner Chunks per Markieren und STRG/CTRL&amp;Enter oder grüner Pfeil rechts wird jedoch auf den globalen Workspace zugegriffen. Beim Schließen von RStudio werden Sie gefragt, ob Sie den globalen Workspace in die .RData als img speichern lassen, dann stehen die Objekte in der nächsten Sitzung wieder zur Verfügung, solange Sie dieselbe Projektdatei öffnen. Offene Skipte und offene Datenansicht-tabs werden beim Schließen ebenfalls mit der Projektdatei assoziiert. Geladene Packages gehen leider verloren, diese müssen Sie jedes Mal beim Starten von RStudio neu laden: library(Packagename). Deshalb ist es Konvention am Anfang jedes Skriptes erstmal die Packages zu laden. Haben Sie Objekte im Workspace gespeichert, können Sie deren Namen verwenden, um sich auf diese zu beziehen und z.B. weitere Berechnungen vorzunehmen. 4.5 Einfache Berechnungen 4.5.1 Rechnen mit Values x &lt;- 5 # definiert den Wert der Variable x y &lt;- 5 # definiert den Wert der Variable x x + y # Summe von x und y x*y # Produkt von x und y sqrt(x) # Wurzel aus x x**(1/2) # x hoch 0.5 Möchten Sie das Ergebnis speichern, müssen Sie dem berechneten Wert einen Namen zuweisen: z &lt;- x + y # weist dem Namen z das Ergebnis dieser Gleichung zu, &quot;z&quot; erscheint im Workspace 4.5.2 Rechnen mit Vektoren Operationen können häufig vektorisiert, d.h. auf alle Objekte einens Vektors angewendet werden: e &lt;- vec_4 * 5 # multipliziert alle Elemente des Vekors mit 5 und speichert das Ergebnis unter dem Namen e Es gibt eine ganze Reihe vorgefertigter Funktionen, um mit Vektoren zu rechnen: 4.5.3 Übersicht Berechnungsfunktionen Folgende Funktionen können Sie auf num-Vektoren und Matrizen anwenden, je nach Funktion auch auf chr Vektoren oder Datensätze, wobei diese sich dann meist nur auf die Einträge in der oberen Ebene, z.B. auf die Anzahl der Spalten und nicht auf die Spalteneinträge beziehen. Funktion Bedeutung Funktion Bedeutung min(x) Minimum mean(x) Mittelwert max(x) Maximum median(x) Median range(x) Range var(x) Varianz sort(x) sortiert x sd(x) Sta ndardabweichung sum(x) Summe aller Elemente quantile(x) Quantile von x cor(x,y) Korrelation von x und y length() Länge von x 4.5.4 Beispiel einer z-Standardisierung eines Vektors mit 3 Einträgen geschwister &lt;- c(8,4,12) # def. der Variable mw_geschw &lt;- mean(geschwister) # MW mw_geschw ## [1] 8 sd_geschw &lt;- sd(geschwister) # SD sd_geschw ## [1] 4 z_geschw &lt;- (geschwister-mw_geschw)/sd_geschw # z-Standardisierung des Vektors z_geschw ## [1] 0 -1 1 4.6 Matrizen Matrizen sind 2D Datenstrukturen, sie bestehenaus Vektoren gleicher Länge und enthalten einen Datentyp. Mit dem Befehl matrix() können sie erstellt werden: mat &lt;- matrix(NaN, nrow=4, ncol=4) # Eine Matrix mat mit 4 Reihen, 4 Spalten und leeren Einträgen wird erstellt # NaN (Not a Number) ist zwar ein double, aber rechnen kann man damit nicht mat ## [,1] [,2] [,3] [,4] ## [1,] NaN NaN NaN NaN ## [2,] NaN NaN NaN NaN ## [3,] NaN NaN NaN NaN ## [4,] NaN NaN NaN NaN Ich habe eine 4x4 Matrix erstellt, die mit NaNs gefüllt ist. Hätte ich diverse Datentypen zugeordnet, wären diese zum niedrigeren coerced worden. Matrizen können mit matrixname[Zeile,Spalte] manipuliert werden. Beispiel: mat[,1] &lt;- vec_4 # Weil Spalte 1. von mat und vec_4 dieselbe Länge haben, kann ich Spalte 1 neu zuweisen. mat # Dadurch, dass der Eintrag für die Zeilennummer leer ist, beziehe ich mich auf alle Zeilen. ## [,1] [,2] [,3] [,4] ## [1,] 1 NaN NaN NaN ## [2,] 3 NaN NaN NaN ## [3,] 3 NaN NaN NaN ## [4,] 7 NaN NaN NaN mat[,2] &lt;- 8 # Wird einem Bereich ein einzelner Wert zugeordnet, wird dieser vervielfacht (wie oben bei NaN) mat ## [,1] [,2] [,3] [,4] ## [1,] 1 8 NaN NaN ## [2,] 3 8 NaN NaN ## [3,] 3 8 NaN NaN ## [4,] 7 8 NaN NaN mat[,3] &lt;- c(FALSE, TRUE) # Wird eine ganzzahlige Teilmenge (2 von 4) zugewiesen, wird diese vervielfacht mat # Anm.: das nennt sich recyclen, ## [,1] [,2] [,3] [,4] ## [1,] 1 8 0 NaN ## [2,] 3 8 1 NaN ## [3,] 3 8 0 NaN ## [4,] 7 8 1 NaN Coercion: TRUE wurde zu 1 und FALSE wurde zu 0. Wenn man nun eine bestimmte Spalte oder Zeile sehen möchte, kann man dies über die Indizierung tun, hierbei kann man sich beliebig austoben. mat[,1] # Ich möchte nur die erste Spalte über alle Zeilen ausgeben ## [1] 1 3 3 7 mat[1,1] # Nur den ersten Wert der ersten Spalte ## [1] 1 Hier wird es turbulent: mat[c(1,3),] # Nur Zeile 1 und 3 von allen Spalten ## [,1] [,2] [,3] [,4] ## [1,] 1 8 0 NaN ## [2,] 3 8 0 NaN mat[-1,2:4] # Nicht Zeile 1 und Spalten 2-4 ## [,1] [,2] [,3] ## [1,] 8 1 NaN ## [2,] 8 0 NaN ## [3,] 8 1 NaN Da ich jetzt Bereiche der Matrix auswählen kann, lohnt es sich Berechnungen vorzunehmen (mat[,2]+mat[,1])*mat[,3] # Spalte 2 minus Spalte 1 und dann mal Spalte 3 ## [1] 0 11 0 15 Es sind immer noch nicht angegebene Nummernwerte in der Matrix, solange ich mich beim Berechnen auf Bereiche der Matrix beschränke, die vergebene numerische Werte haben, gibt es kein Problem, ansonsten schon: mat[1,] # Zeile 1 ## [1] 1 8 0 NaN sum(mat[1,]) # Summe über Zeile 1 mit NaN ## [1] NaN Die Summe kann nicht berechnet werden. Zum Auslassen der NaNs wird das Funktionsargument na.rm=TRUE verwendet: sum(mat[1,], na.rm=TRUE) # Summe über Zeile 1 ohne NaN ## [1] 9 mean(mat, na.rm=TRUE) # MW der Matrix ohne NaN ## [1] 4 Nun, da wir mit dem Rechnen in Matrizen vertraut sind möchte ich die letzte Spalte mit Einträgen füllen: typeof(mat) # gebe den Typ der Einträge der Matrix aus ## [1] &quot;double&quot; mat_sav &lt;- mat # in weiser Voraussicht speichere ich die bisherige Matrix unter anderem Namen mat[,4] &lt;- c(&quot;coercion&quot;,&quot;kann&quot;,&quot;nervig&quot;,&quot;sein&quot;) # weise Spalte 4 einen Vektor mit chr Einträgen zu mat ## [,1] [,2] [,3] [,4] ## [1,] &quot;1&quot; &quot;8&quot; &quot;0&quot; &quot;coercion&quot; ## [2,] &quot;3&quot; &quot;8&quot; &quot;1&quot; &quot;kann&quot; ## [3,] &quot;3&quot; &quot;8&quot; &quot;0&quot; &quot;nervig&quot; ## [4,] &quot;7&quot; &quot;8&quot; &quot;1&quot; &quot;sein&quot; typeof(mat) ## [1] &quot;character&quot; Konnte ich eben noch den Mittelwert einer Spalte bilden, so geht das jetzt nicht mehr, da alle Einträge der Matrix zu chr coerced wurden. In einem typischen Datensatz sind aber Variablen verschiedener Typen (num und chr) enthalten. Dieses Problem ließe sich mit Listen lösen, welche aber unübersichtlich sind. Datensätze bestehen manchmal aus unüberschaubar vielen Einträgen und deshalb müssen sie übersichtlich strukturiert sein. 4.7 tidy Daten Es gibt eine Konvention dafür, wie man Datensätze, die mehreren Beobachtungseinheiten (Fällen) verschiedene Parameter (Variablen) zuordnet. Wichtig für die eigene strukturierte Arbeit ist in erster Linie Konsistenz, z.B. dass Sie bei Variablennamen aus mehreren Wörtern immer den Unterstrich als Trennzeichen verwenden. Es hat sich als überlegen für die Auswertung von Daten herausgestellt, Fälle in Zeilen und Variablen in Spalten einzuordnen, dieses Prinzip dürfte Einigen schon von SPSS bekannt sein. Variable1 Variable2 Was ist ‘tidy’ data? Fall1 Wert11 Wert12 Eine Zeile pro Beobachtung Fall2 Wert21 Wert22 Eine Spalte pro Variable Fall3 Wert31 Wert32 Eine Tabelle pro Untersuchung Fall4 Wert41 Wert42 eindeutige Namen Fall5 Wert51 Wert52 Konsistenz Fall6 Wert61 Wert62 … Es gibt noch weitere Regeln für konsistentes und ordentliches Arbeiten in R und mit Datensätzen im Allgemeinen, z.B. dass man keine Farbcodierungen verwenden sollte. Vorerst genügt es, wenn Sie sich an die Basics hier halten. Diese Art Daten zu strukturieren lässt sich im data.frame und noch besser im tibble umsetzen: Beides sind Tabellen mit Spaltenvektoren, die jeweils verschiedene Datentypen enthalten können. Deswegen stellen beide das bevorzugte und für unsere Zwecke wichtigste Datenformat dar. 4.7.1 tidyverse Bevor wir uns dem schönsten Datenformat, den tibbles widmen, müssen wir das entsprechende Package einmalig in der Console installieren. Ich habe den Code auskommentiert, weil das Package bei mir bereits installiert ist: #install.packages(&quot;tidyverse&quot;) # R kennt den Namen noch nicht, deswegen &quot;&quot; Das Package tidyverse enthält eine Reihe nützlicher Packages, die eine saubere Datenverarbeitung zum Ziel haben. Packages müssen bei jeder Sitzung neu aktiviert bzw. angehängt werden. Für uns relevante Packages im tidyverse sind tibble, readr, stringr, dplyr, purr und ggplot2. library(tidyverse) # Bitte an den Anfang eines Skriptes, um beim Starten der R Session anzuhängen (attach). 4.8 data.frames (df) und tibbles (tib) Es gibt mehr Gemeinsamkeiten als Unterschiede zwischen beiden Datenformaten. Beides sind Tabellen mit Spaltenvektoren (Variablen), die je verschiedene Datentypen enthalten können. Hier zunächst die Übersicht über die Funktionen zum Managen des Datensatzes: Funktion zum data.frame() tibble() Datenformat konvertieren as.data.frame() as_tibble() Definieren data.frame(var1,…) tibble(var1,…) Aufrufen des Datensatzes df tib Auswählen einer Variable df$var tib$var Auswählen eines Bereiches df[rowIdx,colIdx] tib[rowIdx,colIdx] Definieren neuer Variablen df$var_neu &lt;- c(…) tib$var_neu &lt;- c(…) Reihennamen vergeben row.names(df) &lt;-c(“name1”,…) relocate(tib,var) Sie können die beiden Datensatz-Formate einfach in das jeweils andere konvertieren. Die Definition geht per Formel data.frame() und die Aneinanderreihung der Spaltenvektoren. Es bietet sich an, dabei direkt Namen für die Spaltenvektoren zu vergeben. Für tibbles geht das analog mit der Formeltibble() test_df &lt;- data.frame(&quot;text&quot;=mat[,4] , # Komma zwischen Spaltenvektoren &quot;ist_Verb&quot;=mat_sav[,3]) # verwende die Spaltenvektoren aus den vorherigen Matrizen und weise Namen zu test_df ## text ist_Verb ## 1 coercion 0 ## 2 kann 1 ## 3 nervig 0 ## 4 sein 1 In Bezug auf weitere Funktionen des Packages tidyverse sind tibbles ein wenig praktischer. Große tibbles werden übersichtlicher angezeigt (nur die ersten 10 Zeilen) wenn man sie aufruft. test_tib &lt;- as_tibble(test_df) test_tib ## # A tibble: 4 × 2 ## text ist_Verb ## &lt;chr&gt; &lt;dbl&gt; ## 1 coercion 0 ## 2 kann 1 ## 3 nervig 0 ## 4 sein 1 Einzelne Spalten können ganz einfach aufgerufen werden, in dem man den $-Operator benutzt. Schreibt man diesen direkt hinter den Namen des Datensatzes, klappt automatisch eine Liste mit allen Spalten auf: test_tib$text # Mit dem $-Operator können einzelnen Spalten direkt per Name adressiert werden. ## [1] &quot;coercion&quot; &quot;kann&quot; &quot;nervig&quot; &quot;sein&quot; Es ist auch möglich, mehrere Zeilen und/oder Spalten auszugeben, dies funktioniert wie bei Matrizen per Indexnummer: test_tib[2:4,1] # Die Zeilen 2 bis 4 werden aus Spalte 1 ausgebenen ## # A tibble: 3 × 1 ## text ## &lt;chr&gt; ## 1 kann ## 2 nervig ## 3 sein Die Adressierung einzelner Spalten und Zeilen ermöglicht dann zum Beispiel die Berechnung von Kennwerten nur für einzelnen Spalten. Z.B. kann man die Kosten für Konzertkarten im Jahr 2022 aufsummieren lassen: tickets_2022 &lt;- tibble(&quot;Artist&quot;=c(&quot;Ed Sheeran&quot;, &quot;Billy Ellish&quot;, &quot;The Weeknd&quot;, &quot;Dua Lipa&quot;, &quot;Imagine Dragons&quot;), &quot;Kosten&quot;=c(79.32, 282, 116, 136, 68.71 )) sum(tickets_2022$Kosten) ## [1] 682.03 Der $-Operator wird für fast alle höheren Datentypen verwendet, um auf diese Zuzugreifen. Dies gilt zum Beispiel auch für die meisten Outputs von Funktionen (t-Test, Anova, SEMs) und Listen, es müssen aber wie im tibble Namen für die Listeneinträge vergeben sein: liist_of_things &lt;- list(tibbi = test_tib, # erstellt eine Liste aus diversen Objekten in meinem Workspace ticki = tickets_2022, # den Namen der Listeneinträge werden geschwi = geschwister, # die Objekte aus dem Workspace zugeordnet vari = var1) liist_of_things$geschwi # per $-Operator und Name in der Liste wird der Eintrag gewählt ## [1] 8 4 12 liist_of_things$ticki # Und so die Variable ticki (hier das ticket_2022 tibble) ## # A tibble: 5 × 2 ## Artist Kosten ## &lt;chr&gt; &lt;dbl&gt; ## 1 Ed Sheeran 79.3 ## 2 Billy Ellish 282 ## 3 The Weeknd 116 ## 4 Dua Lipa 136 ## 5 Imagine Dragons 68.7 Theoretisch könnte ich auch noch\\$Artist hinzufügen, dann würde mir nur die erste Spalte des tibbles ausgegeben. Mir fällt auf, ich habe den Namen eine Künstlerin in tickets_2022 falsch geschrieben: tickets_2022$Artist[2] &lt;- &quot;Billy Eilish&quot; # $-Operator und Indexing lassen sich kombinieren Sie können also nicht nur Elemente aus Datensätzen abrufen, sondern diese mit dem &lt;- neu zuweisen. Man kann das $ auch verwenden um neue Spalten in die Datensätze einzufügen: tickets_2022$Priorität &lt;- c(2, 4, 3, 5, 1) # definiert eine neue Spalte im Datensatz tickets_2022$Prioritaet &lt;- tickets_2022$Priorität # besser ae statt ä in Variablennamen tickets_2022 # nun gibt es eine Spalte zu viel ## # A tibble: 5 × 4 ## Artist Kosten Priorität Prioritaet ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ed Sheeran 79.3 2 2 ## 2 Billy Eilish 282 4 4 ## 3 The Weeknd 116 3 3 ## 4 Dua Lipa 136 5 5 ## 5 Imagine Dragons 68.7 1 1 tickets_2022$Priorität &lt;- NULL # entfernt eine Spalte, vorsichtig hierbei(!) Ein weitere Unterschied zwischen tibbles und data.frames ist, dass tibbles keine Reihennamen kennen. Das vereinfacht das Format. Möchten Sie trotzdem gerne Reihennamen vergeben, dann müssen Sie sich mit einer neuen Variable(z.B. Reihenname) behelfen, die Sie mit relocate(tib,var) an den Anfang des Datensatzes stellen. 4.8.1 Faktoren Vektoren, die kategoriale Einträge enthalten können Sie mit factor() als Faktor zuweisen: Gegut_vec &lt;- c(&quot;m&quot;, &quot;f&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;,&quot;m&quot;, &quot;f&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;) Gegut_fac &lt;- factor(Gegut_vec) # macht Faktor aus kategorialem Vector und speichert unter Namen Gegut_fac # ruft den Faktor auf: ## [1] m f d f f m f f f m m f m f f m f f f m ## Levels: d f m Es werden die einzelnen Ausprägungen und die möglichen Ausprägungen als Levels ausgegeben. levels() gibt nur die möglichen Ausrägungen eines Faktors aus. Faktoren eignen sich oft besser als Vectoren zum Plotten und Rechnen, deswegen ist es nützlich kategoriale Spaltenvektoren im Datensatz zu Faktoren zu machen. Jetzt, wo Sie mit dem Management von Datensätzen vertraut sind wollen wir vorhandene Datensätze einlesen: 4.9 Einlesen und Speichern von Daten Daten können in R Studio auf unterschiedliche Weise eingelesen werden. Ich habe dieses Bild zur Abwechslung für Ihre Augen erstellt. Es gibt frei verfügbare Datensätze in Packages, z.B. einen Datensatz zu Pinguinen: palmerpenguins. Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/ Nach einmaliger Installation des Packages (install.packages(\"palmerpenguins\") muss es geladen werden: library(palmerpenguins) # jedes Mal beim Durchlaufen des Skripts. Ohne &quot;&quot; pengu &lt;- penguins # penguins ist zwar schon ein tibble, aber Namenszuweisung zum Laden in den Workspace In der Regel werden Sie aber einen selbst erhobenen oder einen aus dem Internet heruntergeladenen Datensatz einlesen wollen. Mein Tipp ist, den Datensatz in das Working Directory zu speichern, dann finden Sie ihn schneller und er ist in der Nähe Ihrer Auswertung, noch eleganter ist es einen Unterordner namens data in den Ordner des Working Directories anzulegen, in den Sie alle Datensätze zu ihrem Projekt speichern können. Im File-tab unten rechts navigieren Sie zu der Datei mit dem Datensatz und dann klicken Sie diese zum Importieren des Datensatzes an (alternativ können Sie im Environment-tab über den Button Import Dataset einen Datensatz zum Importieren auf ihrem Computer suchen). In RStudio erscheint ein Fenster zum Importieren, unten rechts wird der automatisch der dem Dateiformat und unten links angegebenen Optionen entspricht, ggf. werden sogar benötigte Packages geladen. Um einen Datensatz per Code zu importieren sind Dateiformat, die Trennzeichen (sep) und die Dezimalzeichen (dec) besonders relevant. Das Standard-Dateiformat ist .csv, hier sind Kommata Trennzeichen (sep=\",\") und Punkte kennzeichnen Dezimalstellen (dec=\".\"). Sie können die Funktionen read_cvs() oder read_delim() für dieses Dateiformat verwenden, letztere sollte Trenn- und Dezimalzeichen automatisch erkennen. Hier ist eine Übersicht zu den Einlesefunktionen in base R (also ohne zusätzlich geladene Packages) und im tidiverse Package, der Unterschied ist, dass base R Funktionen die Daten in einen data.frame laden, tidyverse Funktionen in ein tibble: Funktion zum sep dec in base R im tidverse autolesen auto . read.delim() read_delim() autolesen auto , read.delim2() read _delim2() lesen von , . read.csv() read_csv() lesen von leer . read.table() read_table() schreiben , . write.csv() write_csv() Wichtigstes und oft einziges Funktionsargument ist der vollständige Dateiname, er wird in \" angegeben. Falls Sie die Datei in einem Unterordner vom Working Directory gespeichert haben, wird den Name des Unterordners mit einem / dem Dateinamen vorangestellt (z.B.“data/Datensatz1.csv”). Das Einlesen von Daten funktioniert nur, wenn der einzulesende Datensatz per &lt;- einem Namen zugewiesen wird. Beispiel zum Laden eines .csv Datensatzes: socken &lt;- read_delim(&quot;data/socken.csv&quot;) # liest meinen socken.csv Datensatz aus dem Unterordner socken # Daten in ein tibble namens socken ## # A tibble: 2 × 3 ## Stoff Gewicht Bewertung ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Seide 0.03 10 ## 2 Wolle 0.08 9 Excel Dateien werden mit Funktionen read_excel(), read_xls() oder read_xlsx() aus dem Package readxl, SPSS Dateien mit der Funktion read_svs() aus dem Package haven eingelesen. Auch zum Einlesen von SAS, Stata oder anderen Dateiformaten gibt es entsprechende Funktionen. Die Standardfunktion zum Abspeichern von Datensätzen in eine Datei ist write_csv(), bzw. in base R write.csv(), da dieses Dateiformat die beste Kompatibilität mit anderer Software aufweist. Beim Speichern muss man neben dem Dateinamen und ggf. Dateipfad noch den Namen des Datensatzes als erstes Funktionsargument angeben: Es gibt noch ein weiteres erwähnenswertes Dateiformat, das von R selbst: .RDS. Die Funktionen saveRDS() und readRDS() bieten die beste Funktionalität in R. 4.10 Datensätze (dat) anschauen Um sich die geladenen Daten ganz anzuschauen kann man sie im Workspace anklicken, oder deren Namen an die Funktion view(dat) übergeben. head(dat) zeigt einem den Kopf des Datensatzes an, genau genommen die ersten 6 Zeilen: long_tib &lt;- tibble(Person_Id=c(1:20), Gender=Gegut_fac, Eigenschaft=var1) # definiert ein 20 x 3 tibble, head(long_tib) # zeigt die ersten 6 Zeilen jeder Variable an ## # A tibble: 6 × 3 ## Person_Id Gender Eigenschaft ## &lt;int&gt; &lt;fct&gt; &lt;chr&gt; ## 1 1 m kreativ ## 2 2 f kreativ ## 3 3 d kreativ ## 4 4 f kreativ ## 5 5 f kreativ ## 6 6 m kreativ Einen Überlick über die Datenstruktur, inklusive Factor-levels erhält man mit der Funktion str(dat): str(long_tib) # zeigt die Struktur der Daten ## tibble [20 × 3] (S3: tbl_df/tbl/data.frame) ## $ Person_Id : int [1:20] 1 2 3 4 5 6 7 8 9 10 ... ## $ Gender : Factor w/ 3 levels &quot;d&quot;,&quot;f&quot;,&quot;m&quot;: 3 2 1 2 2 3 2 2 2 3 ... ## $ Eigenschaft: chr [1:20] &quot;kreativ&quot; &quot;kreativ&quot; &quot;kreativ&quot; &quot;kreativ&quot; ... Zeile 1 gibt Auskunft über Größe und die Klasse des Objektes, tibbles sind eine Art data.frame. In den weiteren Zeilen werden die Datentypen ggf. Faktorlevel und die ersten Werte angezeigt. Mit der Funktion count(dat,var) lassen sich die Häufigkeiten der Levels eines Faktors ausgeben: count(long_tib, Gender) # zählt im long_tib die Levels des Faktors Gender ## # A tibble: 3 × 2 ## Gender n ## &lt;fct&gt; &lt;int&gt; ## 1 d 1 ## 2 f 12 ## 3 m 7 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
