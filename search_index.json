[["index.html", "Einführung in R 1 Über dieses Skript 1.1 Feedback", " Einführung in R José Carlos García Alanis, Jan Goettmann, Cordula Hunt, Florian Kobylka, Anna-Lena Schubert, Meike Steinhilber, 2021-10-18 1 Über dieses Skript Dies ist eine Einführung in die Programmiersprache R, die in verschiedenen Lehrveranstaltungen der Arbeitseinheiten Analyse und Modellierung komplexer Daten und Methodenlehre und Statistik des Psychologischen Instituts der Johannes Gutenberg-Universität Mainz genutzt werden kann. R ist eine unter Psycholog:innen weit verbreitete Programmiersprache, mit deren Hilfe unterschiedlichste Datenarten aufbereitet und analysiert werden können. Das Programm ist Open Source und es gibt eine riesige Community von Entwickler:innen, die an Erweiterungen für die Software arbeiten, um Forschenden das (datenanalytische) Leben zu erleichtern. Dieses Skript wurde als Begleitmaterial für verschiedene Lehrveranstaltungen entwickelt, in denen mit R gearbeitet wird. Es kann als Kursmaterial, aber auch als Nachschlagewerk verwendet werden. Nicht alle Inhalte des Skripts sind für jeden Kurs relevant. Ihre Kursleitung wird Ihnen mitteilen, wann Sie welche Teile des Skripts bearbeiten sollen. Sie können sich natürlich darüber hinaus jederzeit weiter umschauen, welche Möglichkeiten R noch bietet! Ein digitaler Cartoon mit zwei Illustrationen: Die obere zeigt das R-Logo mit einem furchteinflößenden Gesicht und ein kleines, verängstigtes, wuscheliges Monster, das unter einer dunklen Gewitterwolke eine weiße Fahne hochhält, um sich zu ergeben. Der Text darüber lautet: “at first I was like…”. Der untere Cartoon zeigt ein freundliches, lächelndes R-Logo, das aufspringt, um einem glücklichen, unscharfen Monster unter einer lächelnden Sonne und neben bunten Blumen ein High-Five zu geben. Der Text über der unteren Illustration lautet “but now it’s like…” Artwork by Allison Horst 1.1 Feedback Derzeit ist das Skript ein lebendiges Dokument, das auf Basis von Rückmeldungen ständig überarbeitet und verbessert wird. Sollten Ihnen Fehler im Skript auffallen oder sollten Sie sonstiges Feedback haben, freuen wir uns sehr, wenn Sie uns eine E-Mail senden. Schreiben Sie einfach eine E-Mail an amd_lab@uni-mainz.de. "],["einführung.html", "2 Einführung 2.1 Installation 2.2 Erste Schritte 2.3 Das R-Skript 2.4 Struktur des Skripts 2.5 Pakete 2.6 Working Directory", " 2 Einführung 2.1 Installation Um R nutzen zu können, müssen Sie sich sowohl R als auch R-Studio installieren. R ist eine Open-Source-Software, die zur Datenanalyse genutzt wird. Die große Stärke von R in der Verfügbarkeit zahlreicher Zusatzfunktionen, in Form sogenannter Packages. Entwickler:innen überall auf der Welt bieten Packages fals Lösungen für die unterschiedlichsten Probleme an, von der Datenaufbereitung über APA-formatierten Tabellen bis hin zu zahlreichen statistischen Analysen. Laden Sie sich R unter dem folgenden Link herunter und installieren Sie sich das Programm auf Ihrem PC/Laptop: https://cran.r-project.org/ Außerdem benötigen Sie noch R-Studio. R-Studio ist eine „integrierte Entwicklungsumgebung“ (engl: integrated development environment; IDE), die es deutlich einfacher macht, mit R zu arbeiten. Installieren Sie sich daher auch R-Studio auf Ihrem PC/Laptop, indem Sie folgendem Link folgen: https://www.rstudio.com/products/rstudio/download/#download 2.2 Erste Schritte Nachdem Sie R und R-Studio installiert haben, können Sie Ihre ersten Schritte in R machen. Öffnen Sie dazu R-Studio und geben Sie etwas in das Feld “Konsole” (oder “Console”) ein. Im Normalfall finden Sie die Konsole in der Anzeige auf der linken Seite (ggfs. befindet sich die Konsole auch links unten). Sie erkennen die Konsole daran, dass die Zeile, in die Sie etwas eingeben können, mit &gt; beginnt. Diese Klammer fordert Sie auf, R-Code einzugeben! Geben Sie Folgendes in die Konsole ein: &gt; &quot;Hallo R!&quot; Wenn folgende Ausgabe erscheint, hat die Installation funktioniert: ## [1] &quot;Hallo R!&quot; Sie können auch Zahlen in die Konsole eingeben: 42 ## [1] 42 Jetzt können Sie R schon als einfachen Taschenrechner benutzen! Addition: 3+2 ## [1] 5 Subtraktion: 3-2 ## [1] 1 Multiplikation: 3*2 ## [1] 6 Division: 3/2 ## [1] 1.5 Beachten Sie dabei, dass Sie auch Klammern setzen können: (3+2)*5 ## [1] 25 2.3 Das R-Skript In der Regel werden Sie Ihre Analysen nicht direkt in die Konsole eingeben, sondern ein Skript schreiben, in dem Sie Ihre Analysen dokumentieren. Dieses Skript dokumentiert Ihre Analysen, was den großen Vorteil hat, dass Ihre Analysen dadurch reproduzierbar werden. Wenn Sie Daten aufbereiten oder analysieren und dabei unterbrochen werden, können Sie sich - auch noch Tage oder Wochen später - einfach wieder an das Skript setzen, die bisherigen Analyseschritte erneut ausführen und dort weitermachen. So können Sie Ihre Analysen auch mit anderen Studierenden oder Lehrenden, die ein Projekt betreuen, teilen. Viele Forschende laden ihre R-Skripte regelmäßig ins Open Science Framework (OSF) hoch, wenn sie Artikel zur Begutachtung einreichen, damit andere ihren Code und ihre Analysen auf Fehler überprüfen und nachvollziehen können. Um ein solches Skript zu erstellen, nutzen wir den in R-Studio verfügbaren Texteditor. Sie können ein neues Skript unter „Datei \\(\\to\\) NeueDatei \\(\\to\\) R Skript“ („File \\(\\to\\) New File \\(\\to\\) R Script“ öffnen. Skripte, die R-Code enthalten, speichern wir mit der Dateiendung „.r“ oder „.R“ ab. Das Praktische: Wenn Sie Code im Skript schreiben, können Sie diesen Code direkt ausführen. Wenn sich Ihr Cursor in einer Zeile befindet, in der Code steht, können Sie STRG-Enter drücken (oder oben auf das Run-Symbol klicken), um diese Zeile auszuführen. Wenn Sie einen Teil des Skripts markieren, wird nur genau dieser Teil ausgeführt, wenn Sie STRG-Enter drücken. Das Ergebnis wird Ihnen wie gewohnt in der Konsole angezeigt. 2.4 Struktur des Skripts Nichts ist wichtiger als gute Organisation! Damit Sie sich auch später noch daran erinnern, welche Analysen Sie durchgeführt haben, können (und sollten) Sie sich Kommentare ins Skript schreiben. In R wird # benutzt, um Code zu kommentieren. Wenn Sie # vor Code setzen, wird dieser Code beim Ausführen einfach ignoriert! So können Sie sich ganze Abschnitte dazu notieren, welche Analysen Sie gemacht haben, was Kernbefunde waren, usw., ohne dass Sie Probleme beim Ausführen Ihres Skriptes bekommen. Sie sollten Ihren Code immer kommentieren, um sich auch später noch daran erinnern zu können, was Sie vor einiger Zeit geschrieben haben. # 3+2 # Nichts passiert - die Rechnung wurde nicht ausgeführt, weil sie auskommentiert ist Sie können Kommentare auch nutzen, um das Skript in Abschnitte zu gliedern. Wenn Sie hinter ein # noch ein - setzen, fügt der Editor einen logischen Abschnitt ein, den Sie ein- oder ausklappen können. Das ist insbesondere zur Strukturierung längerer Skripte enorm hilfreich. 2.5 Pakete Für R gibt es unzählige nützliche Pakete, die von Entwickler:innen auf der ganzen Welt weiterentwickelt werden. Auch an der JGU werden R-Pakete entwickelt! Diese Pakete erweitern das Grundprogramm und geben Ihnen Tools an die Hand, die Ihnen bei der Bearbeitung ganz konkreter Fragestellungen helfen können. Das Paket psych wurde von William Revelle entwickelt, um verschiedene Funktionen zu bündeln, die für verschiedene psychologische Fragestellungen nützlich sind. Installieren Sie das Paket mit der Funktion install.packages(). install.packages(&quot;psych&quot;) Sobald Sie das Paket installiert haben, müssen Sie es nur noch laden, um es nutzen zu können: library(psych) Und schon haben Sie Ihr erstes Paket installiert und geladen! Sobald Sie ein Paket auf Ihrem PC/Laptop installiert haben, können Sie es immer wieder verwenden. Beachten Sie aber unbedingt, dass Sie Pakete nach jedem Neustart von R neu einladen müssen. Wenn Sie keine Idee haben, welche Funktionen ein Paket umfasst und wofür es nützlich sein könnte, können Sie ganz einfach die Hilfe-Funktion nutzen, die Sie aufrufen können, indem Sie ein Fragezeichen vor den Paketnamen setzen. ?(psych) 2.6 Working Directory Wenn Sie in R arbeiten, arbeiten Sie immer in einem Verzeichnis - einem sog. “working directory”. Sie können sich Ihr aktuelles working directory mit dem Befehl ‘getwd()’ anzeigen lassen. getwd() ## [1] &quot;/Users/runner/work/R-Kurs-Buch/R-Kurs-Buch&quot; In der Regel werden Sie für jedes Projekt ein eigenes working directory anlegen, in dem Sie die Daten und Skripte speichern, die zu dem Projekt gehören. Um in das richtige Verzeichnis zu wechseln, können Sie den Befehl setwd() nutzen. Noch einfacher geht es per Mausklick über Session → Set Working Directory → Choose Directory. Tipp: Noch einfacher geht es mit dem R-Paket here: Wenn Sie bereits ein Verzeichnis für Ihr Projekt angelegt und dort ein Skript gespeichert haben (wichtig: es muss unbedingt im Verzeichnis gespeichert sein!), liest das Paket here automatisch den Pfad aus, an dem ein Skript gespeichert ist. Das ist auch dann enorm praktisch, wenn Sie Ihre Skripte mit anderen austauschen! Eine Karikatur, die zwei Pfade nebeneinander zeigt. Auf der linken Seite ist ein gruseliger, unheimlicher Wald mit Spinnweben und knorrigen Bäumen zu sehen. Auf Ästen stehen Dateipfade wie “~/mmm/nope.csv” und “setwd(”/haha/good/luck/“)” geschrieben. Ein verängstigtes, niedliches, pelziges Monster läuft aus dem gruseligen Wald hinaus. Rechts daneben ist ein heller, farbenfroher Pfad mit Blumen, Regenbogen und Sonnenschein, mit Schildern, auf denen “hier!” und “es ist alles hier!” steht. Ein Monster mit Rucksack und Spazierstock blickt von uns weg in Richtung des rechten Weges. Der stilisierte Text lautet “Hier: Finde deinen Pfad”. Artwork by Allison Horst Dazu müssen Ihr allerdings zunächst einmalig das Paket “here” installieren und dann die Funktion here() in die Funktion setwd() einfügen. install.packages(&quot;here&quot;) setwd(here::here()) "],["erste-schritte-1.html", "3 Erste Schritte 3.1 Variablen 3.2 Vektoren 3.3 Auswahl von Vektorelementen 3.4 Logische Vergleiche", " 3 Erste Schritte 3.1 Variablen Sicherlich wollen Sie Ihre Daten nicht nur in der Konsole ausgeben lassen und bearbeiten, sondern auch in Variablen speichern. Variablen sind Bezeichnungen, mit deren Hilfe Sie auf gespeicherte Daten zugreifen. Sobald eine Variable definiert wurde, können Sie immer wieder darauf zugreifen. Variablen werden mit Hilfe des &lt;- Operators definiert. Sie können sich die Werte dieser Variablen ausgeben lassen, indem Sie die Variablennamen in der Konsole eingeben und Enter drücken. x ## [1] 2 Jetzt können Sie bereits erste Berechnungen mit Variablen durchführen: x+y ## [1] 5 x*y ## [1] 6 In R lassen sich sämtliche Objekte - nicht nur einzelne Zahlen, sondern auch Datentabellen, Wortlisten oder sogar Ergebnisse komplizierter Analysen - in Variablen speichern. Der Workflow ist so ausgelegt, dass Sie Ergebnisse einer Analyse in einer Variable speichern und von dort aus weiterverarbeiten können, z.B. um APA-konforme Tabellen oder Grafiken zu erstellen oder sich Effektstärkemaße ausgeben zu lassen. Im weiteren Verlauf des Kurses lernen Sie andere Datentypen kennen, die in Variablen gespeichert werden können. Achtung: Wenn Sie eine Berechnung mit einer Variable durchführen und das Ergebnis dieser Berechnung speichern möchten, müssen Sie es wieder eine Variable zuweisen - es wird nicht automatisch gespeichert! z &lt;- x*10 Wenn Sie sich jetzt x und z ausgeben lassen, sehen Sie, dass sich nichts an x geändert hat - das Ergebnis der Berechnung wurde nicht abgespeichert. In der Variable z hingegen sehen Sie das Ergebnis Ihrer Berechnung. x ## [1] 2 z ## [1] 20 x, y und z sind denkbar schlechte Variablennamen! Gute Variablennamen sprechen, d.h. dass der Name eine Variable verrät, was sich “in” dieser Variable verbirgt. Deswegen sollten Sie sich immer bemühen, möglichst klare und eindeutige Variablennamen zu vergeben. # Beispiele für gute Variablennamen durchschnittliches_Alter &lt;- 23 MW_Alter &lt;- 23 durchschnittliches_Evaluationsergebnis_KursA &lt;- 2 MW_Evaluationsergebnis_KursA &lt;- 2 Scheuen Sie sich nicht vor langen Variablennamen! Je besser und klarer Sie Ihre Variablen definieren, desto einfacher wird es sowohl Ihnen als auch anderen fallen, Ihren Code nachzuvollziehen. Besonders einfach lesbar sind längere Variablennamen, wenn Sie unterschiedliche Elemente des Variablennamens mit einem Unterstrich trennen. Diese Konvention wird auch in diesem Kurs verwendet. 3.2 Vektoren Jede Spalte eines Datensatzes ist ein Vektor. In einem Vektor befinden sich mehrere Elemente eines Datentyps, also z.B. mehrere Zahlen oder mehrere Wörter. Vektoren werden mit Hilfe des “combine”-Operators c erstellt. Vektor_numeric &lt;- c(1, 2, 3, 4, 5, 6:10) Mit jedem Datentyp können Sie unterschiedliche Operationen durchführen. Um sich den Datentyp eines Vektors anzeigen zu lassen, können Sie die Funktion mode verwenden. mode(Vektor_numeric) ## [1] &quot;numeric&quot; 3.2.1 Datentyp numeric Mit Vektoren vom Typ numeric können Sie verschiedene mathematische Operationen durchführen. Sie können diese Vektoren addieren, multiplizieren, usw. Wenn Sie eine Operation wie *2 auf den Vektor anwenden, wird diese Operation auf alle Elemente des Vektors angewendet. Vektor_numeric*2 ## [1] 2 4 6 8 10 12 14 16 18 20 Wenn Sie hingegen zwei gleich lange Vektoren haben, wird jedes i-te Element des ersten Vektors mit dem i-ten Element des zweiten Vektors verrechnet. Das Element an Position 1 im einen Vektor wird dann mit dem Element an Position 1 im anderen Vektor gepaart, das Element an Position 2 im einen Vektor mit dem Element an Position 2 im anderen Vektor – und so weiter. punkte_MC_Fragen &lt;- c(5, 2, 2, 4, 3, 2, 1, 0, 1, 4) punkte_offene_Fragen &lt;- c(3, 4, 5, 0, 2, 3, 1, 3, 5, 1) klausurergebnis &lt;- punkte_MC_Fragen + punkte_offene_Fragen klausurergebnis ## [1] 8 6 7 4 5 5 2 3 6 5 3.2.2 Datentyp character Wenn Sie in einer Variable Text abspeichern wollen, erschaffen Sie eine Variable vom Datentyp character. Test wird mit doppelten oder einfachen Anführungszeichen angegeben: &quot;Alpha&quot; ## [1] &quot;Alpha&quot; &#39;Beta&#39; ## [1] &quot;Beta&quot; Vektor_character &lt;- c(&quot;Lea&quot;, &quot;Luke&quot;, &quot;Han&quot;, &quot;Chewy&quot;) mode(Vektor_character) ## [1] &quot;character&quot; Mit Vektoren des Typs character können Sie natürlich keine mathematischen Operationen durchführen. Sie sind aber nützlich, um bestimmte Daten zu kodieren, wie bspw. das Geschlecht oder das Studienfach von Versuchspersonen. Geschlecht &lt;- c(&quot;männlich&quot;, &quot;weiblich&quot;, &quot;weiblich&quot;, &quot;divers&quot;, &quot;weiblich&quot;) Studienfach &lt;- c(&quot;Psychologie&quot;, &quot;Medizin&quot;, &quot;Informatik&quot;, &quot;Sportwissenschaft&quot;, &quot;Biologie&quot;) 3.2.3 Datentyp logical Der Datentyp logical kodiert nur binäre Informationen - diese sind entweder TRUE oder FALSE. TRUE ## [1] TRUE FALSE ## [1] FALSE Vektor_logical &lt;- c(TRUE, TRUE, FALSE, TRUE) mode(Vektor_logical) ## [1] &quot;logical&quot; Dabei werden TRUE und FALSE als logische Bedingungen interpretiert, die erfüllt oder nicht erfüllt sein können. Vektoren dieses Datentyps sind für die Datenaufbereitung unglaublich nützlich! Mit Hilfe eines Vektors vom Typ logical können sie beispielsweise kodieren, welche Versuchspersonen die Studie vollständig abgeschlossen haben oder ob einzelne Beobachtungen Ausreißer darstellen. Sie werden diesen Datentyp häufig benötigen, wenn Sie in Datentabellen einzelne Fälle auswählen oder Versuchspersonen ausschließen möchte. Hierbei wird dann jeweils im Einzelfall überprüft, welche Fälle eine gewünschte Bedingung erfüllen (z.B. maximal 30 Minuten zur Bearbeitung eines Tests gebraucht haben) und daher in den weiteren Analysen eingeschlossen werden. # Hier wird festgehalten, welche Versuchspersonen (id) die Studie # vollständig abgeschlossen haben (Studie_abgeschlossen) id &lt;- c(1:10) Studie_abgeschlossen &lt;- c(TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE) Mit logischen Werten kann man die logischen Operationen UND (&amp;), ODER (| ) und NICHT (! ) umsetzen. UND und ODER verknüpfen jeweils zwei logische Bedingungen (sprich: zwei logische Werte, also TRUE/FALSE) miteinander und geben selbst einen logischen Wert zurück. Die Verknüpfung UND ergibt dann TRUE, wenn beide Bedingungen erfüllt sind, d.h. nur wenn die erste und die zweite Bedingung jeweils TRUE sind. ## Logisches UND TRUE &amp; TRUE ## [1] TRUE TRUE &amp; FALSE ## [1] FALSE FALSE &amp; FALSE ## [1] FALSE einen logischen Wert zurück. Die Verknüpfung ODER ergibt dann TRUE, wenn mindestens eine der beiden Bedingungen erfüllt ist, d.h. wenn die erste oder die zweite Bedingung oder beide Bedingungen TRUE sind. Ganz wichtig: ODER gibt auch dann TRUE aus, wenn beide Bedingungen erfüllt sind! ## Logisches ODER TRUE | TRUE ## [1] TRUE TRUE | FALSE ## [1] TRUE FALSE | FALSE ## [1] FALSE Das logische NICHT invertiert eine logische Variable: Aus TRUE wird FALSE und umgekehrt. Das ist hier noch etwas abstrakt, wird aber später in den Kapiteln zur Datenaufbereitung noch klarer. ## Logisches NICHT !TRUE ## [1] FALSE !FALSE ## [1] TRUE 3.2.4 Datentyp factor Variablen vom Datentyp factor sind nützlich, um kategoriale Variablen zu kodieren. Dabei wird zunächst ein Vektor vom Typ ‘numeric’ erstellt. Den einzelnen Werten dieses numerischen Vektors werden dann kategoriale Bezeichnungen zugewiesen. Bedingung &lt;- c (0, 1, 1, 0, 1, 0, 0, 1) Vektor_factor &lt;- factor(x = Bedingung, levels = c(0,1), labels = c(&quot;Kontrollgruppe&quot;, &quot;Experimentalgruppe&quot;)) Vektor_factor ## [1] Kontrollgruppe Experimentalgruppe Experimentalgruppe Kontrollgruppe ## [5] Experimentalgruppe Kontrollgruppe Kontrollgruppe Experimentalgruppe ## Levels: Kontrollgruppe Experimentalgruppe mode(Vektor_factor) ## [1] &quot;numeric&quot; Dazu verwenden Sie die Funktion factor. Dieser Funktion übergeben Sie den numerischen Vektor Bedingung und definieren anschließend die Stufen des Faktors mit Hilfe des Argument levels (hier 0 und 1) sowie die Bezeichnungen mit Hilfe des Argument labels (hier Kontrollgruppe und Experimentalgruppe). Es ist immer sinnvoll, Variablen als Faktoren zu definieren, wenn sie endliche Ausprägungen haben. Experimentelle Bedingungen, Messzeitpunkte oder das Geschlecht von Versuchspersonen sind typische Kandidaten, die als Vektoren vom Typ factor gespeichert werden. Der Vorteil dieses Variablentyps besteht darin, dass Sie dort die Zuordnung von numerischen zu verbalen Bezeichnungen direkt vornehmen können und nachher nicht mehr nachschlagen müssen, ob “0” oder “1” nun die Experimentalgruppe kodiert. Spätestens bei der Auswertung Ihrer Daten sollten Sie solche Variablen also immer als factor rekodieren. Achtung: Sie können mit Faktoren keine mathematischen Operationen durchführen, auch wenn ihnen eigentlich numerische Kodierungen zugrunde liegen. In R werden Vektoren vom Variablentyp factor diesbezüglich ebenso wie Vektoren vom Variablentyp character behandelt. 3.2.5 Datentyp NA Ein Vektor besteht in der Regel nicht nur aus Variablen vom Datentyp NA. In echten Datensätzen werden Sie aber immer mal wieder fehlende Daten haben. Diese werden in R als NA kodiert. alter &lt;- c (21, 25, 29, 24, NA, 19, 23, 24, 20) Achtung: In anderer Statistiksoftware wie z.B. SPSS hat sich die Konvention entwickelt, fehlende Werte nicht mit “NA”, sondern mit bestimmten nicht beobachtbaren numerischen Werten wie “-9” oder “-99” zu beschreiben. Wenn Sie mit einem solchen Datensatz arbeiten, der zuvor in einer anderen Statistiksoftware bearbeitet wurde, sollten Sie immer überprüfen, ob fehlende Werte anhand solcher numerischen Werte kodiert sind und diese als “NA” rekodieren. 3.3 Auswahl von Vektorelementen Sie können auf einzelne Elemente eines Vektor zugreifen, indem Sie den Operator [] verwenden. In die eckigen Klammern wird die Position des Elements eingefügt, das Sie auswählen möchte. Dieses Vorgehen wird Indizierung genannt. daten &lt;- c (3, 7, 9, 0, 1, 1, 4, 5) daten[3] ## [1] 9 # Hier wird das dritte Element ausgewählt Sie können auch eine sogenannte Negativindizierung durchführen, d.h. im Index festhalten, welches Element Sie nicht auswählen möchten. daten[-3] ## [1] 3 7 0 1 1 4 5 # Hier werden alle Elemente außer des dritten ausgewählt Selbstverständlich können Sie auch gleich mehrere Elemente auswählen. Wenn Sie z.B. alles vom zweiten bis fünften Element auswählen wollen, können Sie das im Index so vermerken: [2:5]. Ganz allgemein gilt: Die Zahl vor dem Doppelpunkt gibt an, wo die Indizierung beginnt, und die Zahl nach dem Doppelpunkt gibt an, wo die Indizierung endet. daten[2:5] ## [1] 7 9 0 1 # Hier werden die Elemente 2, 3, 4 und 5 ausgewählt Wenn Sie mehrere Elemente auswählen möchten, die nicht direkt nebeneinander stehen, müssen Sie diese mit dem “combine”-Operator c verknüpfen: daten[c(2, 7)] ## [1] 7 4 # Hier werden die Elemente 2 und 7 ausgewählt Die so ausgewählten Daten können Sie natürlich wieder in einer neuen Variable speichern: ausgewaehlte_daten &lt;- daten[c(2, 7)] 3.4 Logische Vergleiche Logische Vergleiche können genutzt werden, um bestimmte Fälle - z.B. einzelne Versuchspersonen - auszuwählen. Welche logischen Vergleich für einen Datentyp sinnvoll sind, hängt von diesem Datentyp ab. 3.4.1 Datentyp numeric Wenn Sie Daten vom Typ numeric haben, können Sie numerische Vergleiche durchführen. Sie können zum Beispiel überprüfen, welche Ihrer Versuchspersonen älter als 18 Jahre sind. Dazu verwenden Sie den logischen Operator &gt;=, den Sie als “größer oder gleich” interpretieren können (analog dazu liest sich &lt;= als “kleiner oder gleich”.) alter &lt;- c(20, 21, 24, 25, 32, 17, 65, 22) alter &gt;= 18 ## [1] TRUE TRUE TRUE TRUE TRUE FALSE TRUE TRUE Bei numerischen Vektoren können Sie folgende logischen Vergleiche durchführen: (a) gleich (==), (b) größer (&gt;), (c) kleiner (&lt;), (d) größer gleich (&gt;=), (e) kleiner gleich (&lt;=) oder (f) ungleich (!=). Wenn Sie einen logischen Vergleich mit einem gesamten Vektor durchführen, wird für jedes einzelne Element überprüft, ob es der logischen Bedingung entspricht (TRUE) oder nicht (FALSE). # Hier überprüfen wir, welche Versuchspersonen jünger als 18 Jahre sind alter &lt; 18 ## [1] FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE # Wir können auch überprüfen, welche Versuchspersonen genau 18 Jahre sind alter == 18 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 3.4.2 Datentyp character Vektoren vom Typ character lassen sich darauf überprüfen, ob diese identisch mit einer bestimmten Bedingung sind. # Hier wird überprüft, welche Versuchspersonen Psychologie studieren Studienfach &lt;- c(&quot;Psychologie&quot;, &quot;Medizin&quot;, &quot;Informatik&quot;, &quot;Sportwissenschaft&quot;, &quot;Biologie&quot;) Studienfach == &quot;Psychologie&quot; ## [1] TRUE FALSE FALSE FALSE FALSE 3.4.3 Datentyp factor Dieser logische Vergleich lässt sich auch mit Daten vom Typ factor durchführen. Bedingung &lt;- c (0, 1, 1, 0, 1, 0, 0, 1) Bedingung &lt;- factor(x = Bedingung, levels = c(0,1), labels = c(&quot;Kontrollgruppe&quot;, &quot;Experimentalgruppe&quot;)) # Hier wird überprüft, welche Versuchspersonen der Experimentalgruppe angehören Bedingung == &quot;Experimentalgruppe&quot; ## [1] FALSE TRUE TRUE FALSE TRUE FALSE FALSE TRUE 3.4.4 Rekodieren von Variablen mit Hilfe logischer Vergleich Sie werden logische Vergleiche häufig anwenden, um Daten zu rekodieren. Schauen Sie sich dazu die folgenden Beispiele an. Mit Hilfe logischer Vergleiche können Sie überprüfen, ob fehlende Werte nicht mit “NA”, sondern mit “-9” kodiert wurden, um diese anschließend zu rekodieren. Testwerte &lt;- c(80, 57, 93, 85, 72, 65, -9) Testwerte == -9 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE TRUE Sie können das Ergebnis dieses logischen Vergleichs nun nutzen, um alle Werte, die als -9 kodiert wurden, zu rekodieren. Dazu speichern Sie das Ergebnis des logischen Vergleichs einfach in einer neuen Variable ab. fehlende_Werte &lt;- Testwerte == -9 Im nächsten Schritt benutzen Sie die neue erstellte Variable vom Typ logical, um alle Werte des Vektors Testwerte, die den Wert “-9” haben, durch “NA” zu ersetzen. Testwerte[fehlende_Werte] &lt;- NA # Hier wurde der Werte -9 durch NA ersetzt: Testwerte ## [1] 80 57 93 85 72 65 NA Ganz ähnlich können Sie bei einem Reaktionszeitexperiment alle Trials entfernen, in denen Versuchspersonen sehr lange mit ihrer Reaktion gebraucht haben, d.h. in denen sie möglicherweise mit ihrer Aufmerksamkeit abgeschweift sind. # Als erstes werden 1000 Trials einer Versuchsperson simuliert RTs &lt;- rnorm(n = 1000, mean = 500, sd = 100) hist(RTs) # In diesem Vektor von Reaktionszeiten werden alle RTs, die länger als 700 ms sind, entfernt Ausreisser &lt;- RTs &gt; 700 RTs[Ausreisser] &lt;- NA hist(RTs) Für die ganz Eiligen: Sie können dies auch in einem einzigen Schritt durchführen, es ist dann aber fehleranfälliger. Dazu geben Sie den logischen Vergleich direkt als Index an: RTs &lt;- rnorm(n = 1000, mean = 500, sd = 100) # Hier wird der logische Vergleich direkt als Index von RTs genutzt. RTs[RTs &gt; 700] &lt;- NA Alternativ könnten Sie Extremwerte natürlich durch einen sinnvollen Maximalwert ersetzen. Beispielsweise lassen sich Reaktionszeiten, die länger als 700 ms sind, auf 700 ms “deckeln”. RTs &lt;- rnorm(n = 1000, mean = 500, sd = 100) # Hier wird der logische Vergleich direkt als Index von RTs genutzt. RTs[RTs &gt; 700] &lt;- 700 Sie können auch mehrere logische Vergleiche kombinieren. In Reaktionszeitexperimenten wollen Sie meist extrem langsame sowie extrem schnelle Durchgänge ausschließen, weil Sie nicht sicher sein können, ob die Versuchspersonen vorschnell reagiert haben (extrem schnelsl) oder mit ihren Gedanken nicht bei der Sache waren (extrem langsam). Dazu können Sie mehrere logische Vergleiche kombinieren. # Als erstes werden 1000 Trials einer Versuchsperson simuliert RTs &lt;- rnorm(n = 1000, mean = 500, sd = 100) # Dann werden untere und obere Grenzen als Variablen definiert. Dies hat den # Vorteil, dass Sie einfach diese Variablen im Code anpassen können, wenn Sie # die Kriterien zur Ausreißeranalyse anpassen möchten. untere_Grenze &lt;- 300 obere_Grenze &lt;- 700 # In diesem Vektor von Reaktionszeiten werden alle RTs, die schneller als 200 ms # oder länger als 700 ms sind, entfernt. Dazu wird der logische ODER-Operator # benötigt; es sollen solche Trials identifiziert werden, die &lt; 300 ms ODER # &gt; 700 ms sind. Ausreisser &lt;- (RTs &gt; obere_Grenze | RTs &lt; untere_Grenze) RTs[Ausreisser] &lt;- NA # Im Histogramm ist zu sehen, dass sowohl sehr schnelle als auch sehr langsame # Trials aus den Daten entfernt wurden. hist(RTs) "],["datenstruktur.html", "4 Datenstruktur 4.1 RMarkdown 4.2 Hilfe 4.3 Werte &amp; Vektoren 4.4 Der Workspace 4.5 Einfache Berechnungen 4.6 Matrizen 4.7 tidy Daten 4.8 data.frames (df) und tibbles (tib) 4.9 Einlesen und Speichern von Daten 4.10 Datensätze (dat) anschauen", " 4 Datenstruktur Thema Inhalte RMarkdown Titel, Chunks, knitten Hilfe help-Fenster, ?, #was passiert hier Werte, Vektoren &amp; Listen chr, num, log, c(), list(), typeof(), coercion, Abruf von Elementen, list(list()) Workspace rm(), Besen Berechnungen mit Values, Vektoren, Funktionen, z-Standardisierung Matrizen matrix(), Indizierung tidy Daten Zeilen: Beobachtungen, Spalten: Variablen tidyverse Installation und library (package) data.frame &amp; tibble Unterschiede, as.data.frame(), as_tibble(), $, [], Zugriff auf Elemente, Reihennamen, Faktoren Daten laden &amp; speichern Import per klick, read./_, sep=, dec=, .xlsx, .svs, write_csv() Daten anschauen View(), head(), str(), count() 4.1 RMarkdown Das R Markdown Skript ist ein besonderes Dateiformat für R Skripte. Es enthält Fließtext und eingebetteten R Code: Knittet man dies Skript mit dem Wollknäul Button (5.) in der oberen Leiste, integriert es den ausgeführten Code mit dem Fließtext und druckt ein übersichtliches Dokument (html, pdf, txt oder doc). Das ist praktisch um z.B. Auswertungsergebnisse zu präsentieren. Im Header werden Titel und Dokumententyp für das Ausgabe-Dokument festgelegt Die Code Blöcke (Chunks) sind mit je drei rückwärts gestellten Hochkommata (Backticks) am Anfang und Ende des Chunks eingerahmt. Werden sie vom R Markdown Skript als solche erkannt, wird auch die Hintergrundfarbe automatisch abgeändert. Im ersten Chunk sollten globale Chunk Optionen festgelegt, alle notwendigen Packages geladen und die Daten eingelesen werden. Den Fließtext kann man mit Überschriften (#) und Unterüberschriften (##) strukturieren, im Code kennzeichnet # Kommentare Zu Beginn eines Chunks muss man innerhalb einer geschwungenen Klammer spezifizieren(```{…}): Es ist möglich Code von anderen Programmiersprachen (z.B. Python oder TeX) einzubetten, standard ist r (optional) Nach einem Leerzeichen: Einzigartiger Chunk-Name (optional) Nach einem Komma: Befehle, um die Ausgabe des Chunks in das neue Dokument zu steuern: include = FALSE Weder Code noch Ergebnis erscheinen echo = FALSE Nur das Code-Ergebnis erscheint message = FALSE Nachrichten zum Code erscheinen nicht warning = FALSE Warnungenzum Code erscheinen nicht fig.cap = \"...\" Hiermit lassen sich Grafiken beschriften 4.2 Hilfe Sie merken, dass die Befehle und Funktionen zum Teil sehr spezifisch und Sie sich kaum alles behalten können. Am wichtigsten ist die Reihenfolge und Vollständigkeit der Zeichen: vergessen Sie ein Komma, ein Backtick oder eine Klammer zu, dann kann R den Code schon nicht interpretieren. Zum Glück erkennt R Studio das oft und weist einen darauf während des Codens mit einem roten x neben der Zeilennummer hin. Andernfalls dürfen Sie versuchen, die Fehlermeldung beim Ausführen zu verstehen. Wenn Sie den Namen einer Funktion oder eines Packages nicht direkt erinnern, können Sie den Anfang des Namens im Chunk oder in der Console eingeben, RStudio bietet einem nach einem kurzen Moment eine Liste möglicher Optionen an, aus der Sie wählen können. Haben Sie eine Funktion gewählt, können sie die Tab-Taste drücken und es werden die verschiedenen Funktionsargumente angezeigt, um die Funktion zu spezifizieren, was oft sehr hilfreich ist. Möchten Sie wissen, was eine Funktion macht oder in welcher Reihenfolge die Funktionsargumente eingegeben werden, können Sie ?FUN in die Console eintippen, wobei FUN Platzhalter für den Funktionsnamen ist. Alternativ können Sie im Help-tab unten rechts suchen. Die Dokumentation ist oft sehr ausführlich. Die Möglichkeit einschlägige Suchmaschinen im Internet zu verwenden ist fast zu trivial, um sie hier aufzuführen, oft werden Sie dabei auf StackOverflow weitergeleitet. Auf Englisch gestellte Fragen oder Probleme führen zu besseren Treffern. Noch trivialer ist es, im Skript des Kurses oder im eigenen Code nachzuschauen. Falls Sie gründlich nachlesen möchten, gibt es auch ganze Bücher, die einem eine Einführung in R geben: z.B. R Cookbook oder R for Data Science. 4.3 Werte &amp; Vektoren Datenformate in R sind von einfach zu komplex: Value, Vektor, matrix, (array), data.frame,tibble und list. Die kleinste Objekteinheit in R ist ein Value. Es gibt unterschiedliche Typen von Values: Text, bzw. Charakter (chr), manchmal auch String genannt, (komplexe Zahlen, cmplx) Nummer (num), bzw.double (ganze Zahlen, integer int genannt) logische Werte (logi), manchmal auch Boolean genannt fehlende Werte (NA), Not Available Sie weisen einem Objektnamen einen Wert per &lt;- zu (Shortkey:ALT&amp;-), der Datentyp des Values wird automatisch Rkannt. var1 &lt;- &quot;kreativ&quot; # typ chr var2 &lt;- 3.5 # typ num var3 &lt;- TRUE # typ logi Mit der Funktion typeof() können sie sich den Datentypen anzeigen lassen. Vektoren reihen Werten desselben Datentyps auf c(Wert1, Wert2, ...): vec1 &lt;- c(3, 6, 3.4) # c() kombiniert die Werte zu einem Vektor, der dem Namen zugewiesen wird Fassen Sie Werte von verschiedenen Typen zu einem Vektor zussammen, werden beide Werte zum Typen mit der kleineren Typenzahl umgewandelt (coercion). c(&quot;kreativ&quot;,3.5) # ich versuche ein `chr` und eine `num` zu einem Vektor zu kombinieren ## [1] &quot;kreativ&quot; &quot;3.5&quot; 3.5 wird in \"\" ausgegeben, die Nummer wurde zu Text. 4.3.1 Coercion (Umwandlung von Typen) Sie können den Datentypen auch per Funktion ändern, z.B. as.character(), as.double(): as.character(c(1, TRUE, &quot;abc&quot;, 4.1627)) # Verändert eine Reihe von Werten zum Typ chr ## [1] &quot;1&quot; &quot;TRUE&quot; &quot;abc&quot; &quot;4.1627&quot; as.double(c(2, TRUE, &quot;abc&quot;, 4.1627)) # Verändert die Werte zum Typ double, geht es nicht, erscheinen NAs ## Warning: NAs introduced by coercion ## [1] 2.0000 NA NA 4.1627 Coercion gibt es auch in Matrizen, Arrays (Mehrdimensionale Matrizen) und in Spaltenvektoren von Datensätzen (data.frames und tibbles). Nur Listen können verschiedene Datentypen und Elemente enthalten list(Element1, Element2, ...). Das geht soweit, dass Listen selbst Listen enthalten können. 4.3.2 Aufruf einzelner Elemente per Index: Um auf Elemente zuzugreifen, können Sie deren Indexnummer verwenden: vec_4 &lt;- c(1,3,3,7) #Definition des Vektors vec_4[2] #Abruf des zweiten Elements des Vektors ## [1] 3 Das geht sogar in verschachtelten Listen: mylist &lt;- list(list(1,&quot;a&quot;),c(2,3)) # Definiert eine Liste aus Liste &amp; Vector, die je aus 2 Elementen bestehen mylist[[1]][2] # Ruft Element 1 der äußeren Liste: (1,&quot;a&quot;), und davon Element 2 ab: &quot;a&quot; ## [[1]] ## [1] &quot;a&quot; Ich habe jetzt mehrere Variablen (Values, Vektoren, Listen) definiert, sie sind in meinem RStudio im Environment-tab oben rechts aufgetaucht. 4.4 Der Workspace Rechts oben im Fenster ist das Environment-tab. Hier sieht man alle im globale Workspace definierten Objekte (Datenstrukturen: Werte, Vektoren, Matrizen, Arrays, Listen, data.frames, tibbles; und Funktionen) aufgelistet: Per Doppelklick können Sie die Objekte jeweils einzeln oben links im extra Fenster (Datenansicht-tab ) anschauen. rm(Objektname) ist die Funktion zum Entfernen einzelner Objekte aus dem globalen Workspace. Das Besensymbol im Environment-tab oben rechts fegt den globalen Workspace leer. Es ist zu beachten, dass R Markdown beim knitten nicht auf den globalen Workspace zugreift, sondern einen eigenen Workspace aus dem Code in den Chunks erstellt. Beim Ausführen einzelner Chunks per Markieren und STRG/CTRL&amp;Enter oder grüner Pfeil rechts wird jedoch auf den globalen Workspace zugegriffen. Beim Schließen von RStudio werden Sie gefragt, ob Sie den globalen Workspace in die .RData als img speichern lassen, dann stehen die Objekte in der nächsten Sitzung wieder zur Verfügung, solange Sie dieselbe Projektdatei öffnen. Offene Skipte und offene Datenansicht-tabs werden beim Schließen ebenfalls mit der Projektdatei assoziiert. Geladene Packages gehen leider verloren, diese müssen Sie jedes Mal beim Starten von RStudio neu laden: library(Packagename). Deshalb ist es Konvention am Anfang jedes Skriptes erstmal die Packages zu laden. Haben Sie Objekte im Workspace gespeichert, können Sie deren Namen verwenden, um sich auf diese zu beziehen und z.B. weitere Berechnungen vorzunehmen. 4.5 Einfache Berechnungen 4.5.1 Rechnen mit Values x &lt;- 5 # definiert den Wert der Variable x y &lt;- 5 # definiert den Wert der Variable x x + y # Summe von x und y x*y # Produkt von x und y sqrt(x) # Wurzel aus x x**(1/2) # x hoch 0.5 Möchten Sie das Ergebnis speichern, müssen Sie dem berechneten Wert einen Namen zuweisen: z &lt;- x + y # weist dem Namen z das Ergebnis dieser Gleichung zu, &quot;z&quot; erscheint im Workspace 4.5.2 Rechnen mit Vektoren Operationen können häufig vektorisiert, d.h. auf alle Objekte einens Vektors angewendet werden: e &lt;- vec_4 * 5 # multipliziert alle Elemente des Vekors mit 5 und speichert das Ergebnis unter dem Namen e Es gibt eine ganze Reihe vorgefertigter Funktionen, um mit Vektoren zu rechnen: 4.5.3 Übersicht Berechnungsfunktionen Folgende Funktionen können Sie auf num-Vektoren und Matrizen anwenden, je nach Funktion auch auf chr Vektoren oder Datensätze, wobei diese sich dann meist nur auf die Einträge in der oberen Ebene, z.B. auf die Anzahl der Spalten und nicht auf die Spalteneinträge beziehen. Funktion Bedeutung Funktion Bedeutung min(x) Minimum mean(x) Mittelwert max(x) Maximum median(x) Median range(x) Range var(x) Varianz sort(x) sortiert x sd(x) Sta ndardabweichung sum(x) Summe aller Elemente quantile(x) Quantile von x cor(x,y) Korrelation von x und y length() Länge von x 4.5.4 Beispiel einer z-Standardisierung eines Vektors mit 3 Einträgen geschwister &lt;- c(8,4,12) # def. der Variable mw_geschw &lt;- mean(geschwister) # MW mw_geschw ## [1] 8 sd_geschw &lt;- sd(geschwister) # SD sd_geschw ## [1] 4 z_geschw &lt;- (geschwister-mw_geschw)/sd_geschw # z-Standardisierung des Vektors z_geschw ## [1] 0 -1 1 4.6 Matrizen Matrizen sind 2D Datenstrukturen, sie bestehenaus Vektoren gleicher Länge und enthalten einen Datentyp. Mit dem Befehl matrix() können sie erstellt werden: mat &lt;- matrix(NaN, nrow=4, ncol=4) # Eine Matrix mat mit 4 Reihen, 4 Spalten und leeren Einträgen wird erstellt # NaN (Not a Number) ist zwar ein double, aber rechnen kann man damit nicht mat ## [,1] [,2] [,3] [,4] ## [1,] NaN NaN NaN NaN ## [2,] NaN NaN NaN NaN ## [3,] NaN NaN NaN NaN ## [4,] NaN NaN NaN NaN Ich habe eine 4x4 Matrix erstellt, die mit NaNs gefüllt ist. Hätte ich diverse Datentypen zugeordnet, wären diese zum niedrigeren coerced worden. Matrizen können mit matrixname[Zeile,Spalte] manipuliert werden. Beispiel: mat[,1] &lt;- vec_4 # Weil Spalte 1. von mat und vec_4 dieselbe Länge haben, kann ich Spalte 1 neu zuweisen. mat # Dadurch, dass der Eintrag für die Zeilennummer leer ist, beziehe ich mich auf alle Zeilen. ## [,1] [,2] [,3] [,4] ## [1,] 1 NaN NaN NaN ## [2,] 3 NaN NaN NaN ## [3,] 3 NaN NaN NaN ## [4,] 7 NaN NaN NaN mat[,2] &lt;- 8 # Wird einem Bereich ein einzelner Wert zugeordnet, wird dieser vervielfacht (wie oben bei NaN) mat ## [,1] [,2] [,3] [,4] ## [1,] 1 8 NaN NaN ## [2,] 3 8 NaN NaN ## [3,] 3 8 NaN NaN ## [4,] 7 8 NaN NaN mat[,3] &lt;- c(FALSE, TRUE) # Wird eine ganzzahlige Teilmenge (2 von 4) zugewiesen, wird diese vervielfacht mat # Anm.: das nennt sich recyclen, ## [,1] [,2] [,3] [,4] ## [1,] 1 8 0 NaN ## [2,] 3 8 1 NaN ## [3,] 3 8 0 NaN ## [4,] 7 8 1 NaN Coercion: TRUE wurde zu 1 und FALSE wurde zu 0. Wenn man nun eine bestimmte Spalte oder Zeile sehen möchte, kann man dies über die Indizierung tun, hierbei kann man sich beliebig austoben. mat[,1] # Ich möchte nur die erste Spalte über alle Zeilen ausgeben ## [1] 1 3 3 7 mat[1,1] # Nur den ersten Wert der ersten Spalte ## [1] 1 Hier wird es turbulent: mat[c(1,3),] # Nur Zeile 1 und 3 von allen Spalten ## [,1] [,2] [,3] [,4] ## [1,] 1 8 0 NaN ## [2,] 3 8 0 NaN mat[-1,2:4] # Nicht Zeile 1 und Spalten 2-4 ## [,1] [,2] [,3] ## [1,] 8 1 NaN ## [2,] 8 0 NaN ## [3,] 8 1 NaN Da ich jetzt Bereiche der Matrix auswählen kann, lohnt es sich Berechnungen vorzunehmen (mat[,2]+mat[,1])*mat[,3] # Spalte 2 minus Spalte 1 und dann mal Spalte 3 ## [1] 0 11 0 15 Es sind immer noch nicht angegebene Nummernwerte in der Matrix, solange ich mich beim Berechnen auf Bereiche der Matrix beschränke, die vergebene numerische Werte haben, gibt es kein Problem, ansonsten schon: mat[1,] # Zeile 1 ## [1] 1 8 0 NaN sum(mat[1,]) # Summe über Zeile 1 mit NaN ## [1] NaN Die Summe kann nicht berechnet werden. Zum Auslassen der NaNs wird das Funktionsargument na.rm=TRUE verwendet: sum(mat[1,], na.rm=TRUE) # Summe über Zeile 1 ohne NaN ## [1] 9 mean(mat, na.rm=TRUE) # MW der Matrix ohne NaN ## [1] 4 Nun, da wir mit dem Rechnen in Matrizen vertraut sind möchte ich die letzte Spalte mit Einträgen füllen: typeof(mat) # gebe den Typ der Einträge der Matrix aus ## [1] &quot;double&quot; mat_sav &lt;- mat # in weiser Voraussicht speichere ich die bisherige Matrix unter anderem Namen mat[,4] &lt;- c(&quot;coercion&quot;,&quot;kann&quot;,&quot;nervig&quot;,&quot;sein&quot;) # weise Spalte 4 einen Vektor mit chr Einträgen zu mat ## [,1] [,2] [,3] [,4] ## [1,] &quot;1&quot; &quot;8&quot; &quot;0&quot; &quot;coercion&quot; ## [2,] &quot;3&quot; &quot;8&quot; &quot;1&quot; &quot;kann&quot; ## [3,] &quot;3&quot; &quot;8&quot; &quot;0&quot; &quot;nervig&quot; ## [4,] &quot;7&quot; &quot;8&quot; &quot;1&quot; &quot;sein&quot; typeof(mat) ## [1] &quot;character&quot; Konnte ich eben noch den Mittelwert einer Spalte bilden, so geht das jetzt nicht mehr, da alle Einträge der Matrix zu chr coerced wurden. In einem typischen Datensatz sind aber Variablen verschiedener Typen (num und chr) enthalten. Dieses Problem ließe sich mit Listen lösen, welche aber unübersichtlich sind. Datensätze bestehen manchmal aus unüberschaubar vielen Einträgen und deshalb müssen sie übersichtlich strukturiert sein. 4.7 tidy Daten Es gibt eine Konvention dafür, wie man Datensätze, die mehreren Beobachtungseinheiten (Fällen) verschiedene Parameter (Variablen) zuordnet. Wichtig für die eigene strukturierte Arbeit ist in erster Linie Konsistenz, z.B. dass Sie bei Variablennamen aus mehreren Wörtern immer den Unterstrich als Trennzeichen verwenden. Es hat sich als überlegen für die Auswertung von Daten herausgestellt, Fälle in Zeilen und Variablen in Spalten einzuordnen, dieses Prinzip dürfte Einigen schon von SPSS bekannt sein. Variable1 Variable2 Was ist ‘tidy’ data? Fall1 Wert11 Wert12 Eine Zeile pro Beobachtung Fall2 Wert21 Wert22 Eine Spalte pro Variable Fall3 Wert31 Wert32 Eine Tabelle pro Untersuchung Fall4 Wert41 Wert42 eindeutige Namen Fall5 Wert51 Wert52 Konsistenz Fall6 Wert61 Wert62 … Es gibt noch weitere Regeln für konsistentes und ordentliches Arbeiten in R und mit Datensätzen im Allgemeinen, z.B. dass man keine Farbcodierungen verwenden sollte. Vorerst genügt es, wenn Sie sich an die Basics hier halten. Diese Art Daten zu strukturieren lässt sich im data.frame und noch besser im tibble umsetzen: Beides sind Tabellen mit Spaltenvektoren, die jeweils verschiedene Datentypen enthalten können. Deswegen stellen beide das bevorzugte und für unsere Zwecke wichtigste Datenformat dar. 4.7.1 tidyverse Bevor wir uns dem schönsten Datenformat, den tibbles widmen, müssen wir das entsprechende Package einmalig in der Console installieren. Ich habe den Code auskommentiert, weil das Package bei mir bereits installiert ist: #install.packages(&quot;tidyverse&quot;) # R kennt den Namen noch nicht, deswegen &quot;&quot; Das Package tidyverse enthält eine Reihe nützlicher Packages, die eine saubere Datenverarbeitung zum Ziel haben. Packages müssen bei jeder Sitzung neu aktiviert bzw. angehängt werden. Für uns relevante Packages im tidyverse sind tibble, readr, stringr, dplyr, purr und ggplot2. library(tidyverse) # Bitte an den Anfang eines Skriptes, um beim Starten der R Session anzuhängen (attach). 4.8 data.frames (df) und tibbles (tib) Es gibt mehr Gemeinsamkeiten als Unterschiede zwischen beiden Datenformaten. Beides sind Tabellen mit Spaltenvektoren (Variablen), die je verschiedene Datentypen enthalten können. Hier zunächst die Übersicht über die Funktionen zum Managen des Datensatzes: Funktion zum data.frame() tibble() Datenformat konvertieren as.data.frame() as_tibble() Definieren data.frame(var1,…) tibble(var1,…) Aufrufen des Datensatzes df tib Auswählen einer Variable df$var tib$var Auswählen eines Bereiches df[rowIdx,colIdx] tib[rowIdx,colIdx] Definieren neuer Variablen df$var_neu &lt;- c(…) tib$var_neu &lt;- c(…) Reihennamen vergeben row.names(df) &lt;-c(“name1”,…) relocate(tib,var) Sie können die beiden Datensatz-Formate einfach in das jeweils andere konvertieren. Die Definition geht per Formel data.frame() und die Aneinanderreihung der Spaltenvektoren. Es bietet sich an, dabei direkt Namen für die Spaltenvektoren zu vergeben. Für tibbles geht das analog mit der Formeltibble() test_df &lt;- data.frame(&quot;text&quot;=mat[,4] , # Komma zwischen Spaltenvektoren &quot;ist_Verb&quot;=mat_sav[,3]) # verwende die Spaltenvektoren aus den vorherigen Matrizen und weise Namen zu test_df ## text ist_Verb ## 1 coercion 0 ## 2 kann 1 ## 3 nervig 0 ## 4 sein 1 In Bezug auf weitere Funktionen des Packages tidyverse sind tibbles ein wenig praktischer. Große tibbles werden übersichtlicher angezeigt (nur die ersten 10 Zeilen) wenn man sie aufruft. test_tib &lt;- as_tibble(test_df) test_tib ## # A tibble: 4 × 2 ## text ist_Verb ## &lt;chr&gt; &lt;dbl&gt; ## 1 coercion 0 ## 2 kann 1 ## 3 nervig 0 ## 4 sein 1 Einzelne Spalten können ganz einfach aufgerufen werden, in dem man den $-Operator benutzt. Schreibt man diesen direkt hinter den Namen des Datensatzes, klappt automatisch eine Liste mit allen Spalten auf: test_tib$text # Mit dem $-Operator können einzelnen Spalten direkt per Name adressiert werden. ## [1] &quot;coercion&quot; &quot;kann&quot; &quot;nervig&quot; &quot;sein&quot; Es ist auch möglich, mehrere Zeilen und/oder Spalten auszugeben, dies funktioniert wie bei Matrizen per Indexnummer: test_tib[2:4,1] # Die Zeilen 2 bis 4 werden aus Spalte 1 ausgebenen ## # A tibble: 3 × 1 ## text ## &lt;chr&gt; ## 1 kann ## 2 nervig ## 3 sein Die Adressierung einzelner Spalten und Zeilen ermöglicht dann zum Beispiel die Berechnung von Kennwerten nur für einzelnen Spalten. Z.B. kann man die Kosten für Konzertkarten im Jahr 2022 aufsummieren lassen: tickets_2022 &lt;- tibble(&quot;Artist&quot;=c(&quot;Ed Sheeran&quot;, &quot;Billy Ellish&quot;, &quot;The Weeknd&quot;, &quot;Dua Lipa&quot;, &quot;Imagine Dragons&quot;), &quot;Kosten&quot;=c(79.32, 282, 116, 136, 68.71 )) sum(tickets_2022$Kosten) ## [1] 682.03 Der $-Operator wird für fast alle höheren Datentypen verwendet, um auf diese Zuzugreifen. Dies gilt zum Beispiel auch für die meisten Outputs von Funktionen (t-Test, Anova, SEMs) und Listen, es müssen aber wie im tibble Namen für die Listeneinträge vergeben sein: liist_of_things &lt;- list(tibbi = test_tib, # erstellt eine Liste aus diversen Objekten in meinem Workspace ticki = tickets_2022, # den Namen der Listeneinträge werden geschwi = geschwister, # die Objekte aus dem Workspace zugeordnet vari = var1) liist_of_things$geschwi # per $-Operator und Name in der Liste wird der Eintrag gewählt ## [1] 8 4 12 liist_of_things$ticki # Und so die Variable ticki (hier das ticket_2022 tibble) ## # A tibble: 5 × 2 ## Artist Kosten ## &lt;chr&gt; &lt;dbl&gt; ## 1 Ed Sheeran 79.3 ## 2 Billy Ellish 282 ## 3 The Weeknd 116 ## 4 Dua Lipa 136 ## 5 Imagine Dragons 68.7 Theoretisch könnte ich auch noch\\$Artist hinzufügen, dann würde mir nur die erste Spalte des tibbles ausgegeben. Mir fällt auf, ich habe den Namen eine Künstlerin in tickets_2022 falsch geschrieben: tickets_2022$Artist[2] &lt;- &quot;Billy Eilish&quot; # $-Operator und Indexing lassen sich kombinieren Sie können also nicht nur Elemente aus Datensätzen abrufen, sondern diese mit dem &lt;- neu zuweisen. Man kann das $ auch verwenden um neue Spalten in die Datensätze einzufügen: tickets_2022$Priorität &lt;- c(2, 4, 3, 5, 1) # definiert eine neue Spalte im Datensatz tickets_2022$Prioritaet &lt;- tickets_2022$Priorität # besser ae statt ä in Variablennamen tickets_2022 # nun gibt es eine Spalte zu viel ## # A tibble: 5 × 4 ## Artist Kosten Priorität Prioritaet ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ed Sheeran 79.3 2 2 ## 2 Billy Eilish 282 4 4 ## 3 The Weeknd 116 3 3 ## 4 Dua Lipa 136 5 5 ## 5 Imagine Dragons 68.7 1 1 tickets_2022$Priorität &lt;- NULL # entfernt eine Spalte, vorsichtig hierbei(!) Ein weitere Unterschied zwischen tibbles und data.frames ist, dass tibbles keine Reihennamen kennen. Das vereinfacht das Format. Möchten Sie trotzdem gerne Reihennamen vergeben, dann müssen Sie sich mit einer neuen Variable(z.B. Reihenname) behelfen, die Sie mit relocate(tib,var) an den Anfang des Datensatzes stellen. 4.8.1 Faktoren Vektoren, die kategoriale Einträge enthalten können Sie mit factor() als Faktor zuweisen: Gegut_vec &lt;- c(&quot;m&quot;, &quot;f&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;,&quot;m&quot;, &quot;f&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;) Gegut_fac &lt;- factor(Gegut_vec) # macht Faktor aus kategorialem Vector und speichert unter Namen Gegut_fac # ruft den Faktor auf: ## [1] m f d f f m f f f m m f m f f m f f f m ## Levels: d f m Es werden die einzelnen Ausprägungen und die möglichen Ausprägungen als Levels ausgegeben. levels() gibt nur die möglichen Ausrägungen eines Faktors aus. Faktoren eignen sich oft besser als Vectoren zum Plotten und Rechnen, deswegen ist es nützlich kategoriale Spaltenvektoren im Datensatz zu Faktoren zu machen. Jetzt, wo Sie mit dem Management von Datensätzen vertraut sind wollen wir vorhandene Datensätze einlesen: 4.9 Einlesen und Speichern von Daten Daten können in R Studio auf unterschiedliche Weise eingelesen werden. Ich habe dieses Bild zur Abwechslung für Ihre Augen erstellt. Es gibt frei verfügbare Datensätze in Packages, z.B. einen Datensatz zu Pinguinen: palmerpenguins. Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/ Nach einmaliger Installation des Packages (install.packages(\"palmerpenguins\") muss es geladen werden: library(palmerpenguins) # jedes Mal beim Durchlaufen des Skripts. Ohne &quot;&quot; pengu &lt;- penguins # penguins ist zwar schon ein tibble, aber Namenszuweisung zum Laden in den Workspace In der Regel werden Sie aber einen selbst erhobenen oder einen aus dem Internet heruntergeladenen Datensatz einlesen wollen. Mein Tipp ist, den Datensatz in das Working Directory zu speichern, dann finden Sie ihn schneller und er ist in der Nähe Ihrer Auswertung, noch eleganter ist es einen Unterordner namens data in den Ordner des Working Directories anzulegen, in den Sie alle Datensätze zu ihrem Projekt speichern können. Im File-tab unten rechts navigieren Sie zu der Datei mit dem Datensatz und dann klicken Sie diese zum Importieren des Datensatzes an (alternativ können Sie im Environment-tab über den Button Import Dataset einen Datensatz zum Importieren auf ihrem Computer suchen). In RStudio erscheint ein Fenster zum Importieren, unten rechts wird der automatisch der dem Dateiformat und unten links angegebenen Optionen entspricht, ggf. werden sogar benötigte Packages geladen. Um einen Datensatz per Code zu importieren sind Dateiformat, die Trennzeichen (sep) und die Dezimalzeichen (dec) besonders relevant. Das Standard-Dateiformat ist .csv, hier sind Kommata Trennzeichen (sep=\",\") und Punkte kennzeichnen Dezimalstellen (dec=\".\"). Sie können die Funktionen read_cvs() oder read_delim() für dieses Dateiformat verwenden, letztere sollte Trenn- und Dezimalzeichen automatisch erkennen. Hier ist eine Übersicht zu den Einlesefunktionen in base R (also ohne zusätzlich geladene Packages) und im tidiverse Package, der Unterschied ist, dass base R Funktionen die Daten in einen data.frame laden, tidyverse Funktionen in ein tibble: Funktion zum sep dec in base R im tidverse autolesen auto . read.delim() read_delim() autolesen auto , read.delim2() read _delim2() lesen von , . read.csv() read_csv() lesen von leer . read.table() read_table() schreiben , . write.csv() write_csv() Wichtigstes und oft einziges Funktionsargument ist der vollständige Dateiname, er wird in \" angegeben. Falls Sie die Datei in einem Unterordner vom Working Directory gespeichert haben, wird den Name des Unterordners mit einem / dem Dateinamen vorangestellt (z.B.“data/Datensatz1.csv”). Das Einlesen von Daten funktioniert nur, wenn der einzulesende Datensatz per &lt;- einem Namen zugewiesen wird. Beispiel zum Laden eines .csv Datensatzes: socken &lt;- read_delim(&quot;data/socken.csv&quot;) # liest meinen socken.csv Datensatz aus dem Unterordner socken # Daten in ein tibble namens socken ## # A tibble: 2 × 3 ## Stoff Gewicht Bewertung ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Seide 0.03 10 ## 2 Wolle 0.08 9 Excel Dateien werden mit Funktionen read_excel(), read_xls() oder read_xlsx() aus dem Package readxl, SPSS Dateien mit der Funktion read_svs() aus dem Package haven eingelesen. Auch zum Einlesen von SAS, Stata oder anderen Dateiformaten gibt es entsprechende Funktionen. Die Standardfunktion zum Abspeichern von Datensätzen in eine Datei ist write_csv(), bzw. in base R write.csv(), da dieses Dateiformat die beste Kompatibilität mit anderer Software aufweist. Beim Speichern muss man neben dem Dateinamen und ggf. Dateipfad noch den Namen des Datensatzes als erstes Funktionsargument angeben: Es gibt noch ein weiteres erwähnenswertes Dateiformat, das von R selbst: .RDS. Die Funktionen saveRDS() und readRDS() bieten die beste Funktionalität in R. 4.10 Datensätze (dat) anschauen Um sich die geladenen Daten ganz anzuschauen kann man sie im Workspace anklicken, oder deren Namen an die Funktion view(dat) übergeben. head(dat) zeigt einem den Kopf des Datensatzes an, genau genommen die ersten 6 Zeilen: long_tib &lt;- tibble(Person_Id=c(1:20), Gender=Gegut_fac, Eigenschaft=var1) # definiert ein 20 x 3 tibble, head(long_tib) # zeigt die ersten 6 Zeilen jeder Variable an ## # A tibble: 6 × 3 ## Person_Id Gender Eigenschaft ## &lt;int&gt; &lt;fct&gt; &lt;chr&gt; ## 1 1 m kreativ ## 2 2 f kreativ ## 3 3 d kreativ ## 4 4 f kreativ ## 5 5 f kreativ ## 6 6 m kreativ Einen Überlick über die Datenstruktur, inklusive Factor-levels erhält man mit der Funktion str(dat): str(long_tib) # zeigt die Struktur der Daten ## tibble [20 × 3] (S3: tbl_df/tbl/data.frame) ## $ Person_Id : int [1:20] 1 2 3 4 5 6 7 8 9 10 ... ## $ Gender : Factor w/ 3 levels &quot;d&quot;,&quot;f&quot;,&quot;m&quot;: 3 2 1 2 2 3 2 2 2 3 ... ## $ Eigenschaft: chr [1:20] &quot;kreativ&quot; &quot;kreativ&quot; &quot;kreativ&quot; &quot;kreativ&quot; ... Zeile 1 gibt Auskunft über Größe und die Klasse des Objektes, tibbles sind eine Art data.frame. In den weiteren Zeilen werden die Datentypen ggf. Faktorlevel und die ersten Werte angezeigt. Mit der Funktion count(dat,var) lassen sich die Häufigkeiten der Levels eines Faktors ausgeben: count(long_tib, Gender) # zählt im long_tib die Levels des Faktors Gender ## # A tibble: 3 × 2 ## Gender n ## &lt;fct&gt; &lt;int&gt; ## 1 d 1 ## 2 f 12 ## 3 m 7 "],["datenaufbereitung-mit-dplyr.html", "5 Datenaufbereitung mit dplyr 5.1 Einführung in Dplyr und tidyverse 5.2 Dplyr: Die wichtigsten Befehle 5.3 Übung 1 5.4 Dplyr: Der Piping Operator 5.5 Beispiel 5.6 Übung 2 5.7 Dplyr : Neue Variablen mit mutate() berechnen 5.8 Beispiel 5.9 Aufgabe bis zum nächsten Mal", " 5 Datenaufbereitung mit dplyr 5.1 Einführung in Dplyr und tidyverse Dplyr ist Teil des tidyverse Packages und ermöglicht es, Daten sehr einfach zu manipulieren und in eine Form zu bringen, um diese dann zu analysieren. Um das zu tun greifen wir auf den Star Wars Datensatz zurück, den das dplyr Package mitliefert: # Lest die Daten bitte ein, der Datensatz heisst &quot;starwars.RDS&quot; und befindet sich in eurem Projektordner, diesmal benutzen wir den readRDS() Befehl. starwars &lt;- readRDS(&quot;starwars.RDS&quot;) Der Datensatz enthält Informationen über unsere Star Wars Helden, ähnlich dem Datensatz, den wir uns in der letzten Sitzung ausgedacht haben: head(starwars,5) # Wir lassen uns erstmal die ersten 5 Zeilen des Datensatzes ausgeben ## # A tibble: 5 × 11 ## name height mass hair_color skin_color eye_color Age sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Luke Skywalker 172 77 blond fair blue 19 male mascu… ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu… ## 3 R2-D2 96 32 &lt;NA&gt; white, blue red 33 none mascu… ## 4 Darth Vader 202 136 none white yellow 41.9 male mascu… ## 5 Leia Organa 150 49 brown light brown 19 fema… femin… ## # … with 2 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt; Bevor wir einsteigen, schaut euch an, wie die einzelnen Variablen im Datensatz verteilt sind. Benutzt dazu den den summary() Befehl, was fällt euch auf ? summary(starwars) ## name height mass hair_color skin_color ## Length:87 Min. : 66.0 Min. : 15.00 none :37 fair :17 ## Class :character 1st Qu.:167.0 1st Qu.: 55.60 brown :18 light :11 ## Mode :character Median :180.0 Median : 79.00 black :13 dark : 6 ## Mean :174.4 Mean : 97.31 white : 4 green : 6 ## 3rd Qu.:191.0 3rd Qu.: 84.50 blond : 3 grey : 6 ## Max. :264.0 Max. :1358.00 (Other): 7 pale : 5 ## NA&#39;s :6 NA&#39;s :28 NA&#39;s : 5 (Other):36 ## eye_color Age sex gender ## brown :21 Min. : 8.00 female :16 feminine :17 ## blue :19 1st Qu.: 35.00 hermaphroditic: 1 masculine:66 ## yellow :11 Median : 52.00 male :60 NA&#39;s : 4 ## black :10 Mean : 87.57 none : 6 ## orange : 8 3rd Qu.: 72.00 NA&#39;s : 4 ## red : 5 Max. :896.00 ## (Other):13 NA&#39;s :44 ## homeworld species ## Length:87 Length:87 ## Class :character Class :character ## Mode :character Mode :character ## ## ## ## 5.2 Dplyr: Die wichtigsten Befehle Filtern von Beobachtungen nach Wert (filter()). Reihen neu Sortieren (arrange()). Auswahl von Variablen nach Name (select()). Erstellen von neuen Variablen aus bereits existierenden (mutate()). Viele Werte zu einem einzelnen Wert zusammenfassen (summarise()). Der vielleicht wichtigste Befehl ist der group_by() Befehl, mit dem Ihr die oben genannten Befehle auf einzelne Gruppen innerhalb eines Datensatzes anwenden könnt. Diese 6 sogennaten “Verben” bilden die Grundlage für tidyverse.Damit ist es möglichmehrere einfache Schritte miteinander zu verketten, um ein komplexes Ergebnis zu erzielen. Alles Befehle funktionieren auf die gleiche Art und Weise: Das erste Argument ist ein Dataframe. Die nachfolgenden Argumente beschreiben, was mit dem Dataframe geschehen soll, wobei die Variablennamen (ohne Anführungszeichen) verwendet werden. Das Ergebnis ist ein neuer Dataframe Hier ein Beispiel, zum filter() Befehl, dazu müsst ihr auch wissen, wie Ihr die gewünschten Beobachtungen mit Hilfe der Vergleichsoperatoren auswählen können. R bietet euch hier die Standardoperatoren: &gt; (größer) &gt;= (größer gleich) &lt; (kleiner) &lt;= (kleiner gleich) != (nicht gleich) ==(gleich) Anmerkung: Es gibt auch noch logische Operatoren, also “und”, “oder” etc. Diese Besprechen wir nicht im Detail, da das sonst zu viel würde. Die Logik der Anwendungen ist aber genau gleich wie bei den Vergleichsoperatoren, hier nur der Vollstädigkeit halber eine übersicht über diese Operatoren: Logische Operatoren in R Beispiel # Wenn wir zum Beispiel wissen wollen, wer die größten und schwersten Charaktere aus Starwars sind, dann könnten wir dies so machen: filter(starwars, height &gt; 190, mass &gt; 90) ## # A tibble: 6 × 11 ## name height mass hair_color skin_color eye_color Age sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Darth Vader 202 136 none white yellow 41.9 male mascu… ## 2 Chewbacca 228 112 brown unknown blue 200 male mascu… ## 3 IG-88 200 140 none metal red 15 none mascu… ## 4 Dexter Jettster 198 102 none brown yellow NA male mascu… ## 5 Grievous 216 159 none brown, wh… green, y… NA male mascu… ## 6 Tarfful 234 136 brown brown blue NA male mascu… ## # … with 2 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt; # Wir filtern hier alle heraus, die größer sind als 190 und mehr als 90 Kilo wiegen Wenn man mit Strings arbeitet sucht man häufig nach bestimmen pattern in den Strings, wie hier bei den Namen. Wollen wir nun alle Skywalkers filtern, müssen wir die grepl() Funktion aus R nutzen. Diese prüft, ob eine Zeichenfolge vorhanden ist oder nicht und gibt dann entsprechend TRUE oder FALSE aus, also perfekt für filter() . Bei Strings die nur aus einem Wort bestehen, funktioniert aber auch filter(starwars, species==\"human\"). Beispiel: filter(starwars, species == &quot;Human&quot;) ## # A tibble: 35 × 11 ## name height mass hair_color skin_color eye_color Age sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Luke Skywa… 172 77 blond fair blue 19 male mascul… ## 2 Darth Vader 202 136 none white yellow 41.9 male mascul… ## 3 Leia Organa 150 49 brown light brown 19 fema… femini… ## 4 Owen Lars 178 120 brown, grey light blue 52 male mascul… ## 5 Beru White… 165 75 brown light blue 47 fema… femini… ## 6 Biggs Dark… 183 84 black light brown 24 male mascul… ## 7 Obi-Wan Ke… 182 77 auburn, wh… fair blue-gray 57 male mascul… ## 8 Anakin Sky… 188 84 blond fair blue 41.9 male mascul… ## 9 Wilhuff Ta… 180 NA auburn, gr… fair blue 64 male mascul… ## 10 Han Solo 180 80 brown fair brown 29 male mascul… ## # … with 25 more rows, and 2 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt; # Alle Helden, mit dem Nachnamen Skywalker filter(starwars, grepl(&quot;Skywalker&quot;, name)) ## # A tibble: 3 × 11 ## name height mass hair_color skin_color eye_color Age sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Luke Skywal… 172 77 blond fair blue 19 male mascul… ## 2 Anakin Skyw… 188 84 blond fair blue 41.9 male mascul… ## 3 Shmi Skywal… 163 NA black fair brown 72 female femini… ## # … with 2 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt; # Es wird im Datensatz starwars nach dem String &quot;Skywalker&quot; in der Spalte name gesucht. # Das Ergebnis sieht dann so aus: Wichtig ist natürlich für uns auch der Umgang mit Faktoren. Glücklicherweise ist das viel einfacher als mit Strings: # Wenn wir nun nach einem bestimmten Faktor-Level Filtern wollen geht das genauso wie mit numerischen Werten: filter(starwars, sex == &quot;male&quot;) ## # A tibble: 60 × 11 ## name height mass hair_color skin_color eye_color Age sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Luke Skywa… 172 77 blond fair blue 19 male mascul… ## 2 Darth Vader 202 136 none white yellow 41.9 male mascul… ## 3 Owen Lars 178 120 brown, grey light blue 52 male mascul… ## 4 Biggs Dark… 183 84 black light brown 24 male mascul… ## 5 Obi-Wan Ke… 182 77 auburn, wh… fair blue-gray 57 male mascul… ## 6 Anakin Sky… 188 84 blond fair blue 41.9 male mascul… ## 7 Wilhuff Ta… 180 NA auburn, gr… fair blue 64 male mascul… ## 8 Chewbacca 228 112 brown unknown blue 200 male mascul… ## 9 Han Solo 180 80 brown fair brown 29 male mascul… ## 10 Greedo 173 74 &lt;NA&gt; green black 44 male mascul… ## # … with 50 more rows, and 2 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt; 5.3 Übung 1 Filtert nun selbst den Datensatz nach bestimmten Kriterien # 1.) Filtert alle Helden, die Älter sind als 20 und größer als 160 sind fat_starwars &lt;- filter(starwars, Age &gt; 20, height &gt; 160) # 2.) Filtert alle Helden, die Blaue Augen haben und männlich sind filter(starwars, eye_color == &quot;blue&quot;, sex == &quot;male&quot;) ## # A tibble: 12 × 11 ## name height mass hair_color skin_color eye_color Age sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Luke Skywa… 172 77 blond fair blue 19 male mascul… ## 2 Owen Lars 178 120 brown, grey light blue 52 male mascul… ## 3 Anakin Sky… 188 84 blond fair blue 41.9 male mascul… ## 4 Wilhuff Ta… 180 NA auburn, gr… fair blue 64 male mascul… ## 5 Chewbacca 228 112 brown unknown blue 200 male mascul… ## 6 Jek Tono P… 180 110 brown fair blue NA male mascul… ## 7 Lobot 175 79 none light blue 37 male mascul… ## 8 Qui-Gon Ji… 193 89 brown fair blue 92 male mascul… ## 9 Finis Valo… 170 NA blond fair blue 91 male mascul… ## 10 Mas Amedda 196 NA none blue blue NA male mascul… ## 11 Cliegg Lars 183 NA brown fair blue 82 male mascul… ## 12 Tarfful 234 136 brown brown blue NA male mascul… ## # … with 2 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt; # 3.) Filtert alle, die zur Spezies Droid gehören filter(starwars, species==&quot;Droid&quot;) ## # A tibble: 6 × 11 ## name height mass hair_color skin_color eye_color Age sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none masculine ## 2 R2-D2 96 32 &lt;NA&gt; white, blue red 33 none masculine ## 3 R5-D4 97 32 &lt;NA&gt; white, red red NA none masculine ## 4 IG-88 200 140 none metal red 15 none masculine ## 5 R4-P17 96 NA none silver, red red, blue NA none feminine ## 6 BB8 NA NA none none black NA none masculine ## # … with 2 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt; 5.4 Dplyr: Der Piping Operator Jetzt wisst ihr, wie man Daten filtert. Das ist aber nur eine der Basisfunktionen von dplyr. Die vielleicht wichtigste Funktion der sogenannte “piping operator” %&gt;% Mit diesem könnt ihr die Befehle kombinieren, oder auch “verketten” um die Datensätze nach euren Wünschen umzugestalten. Das funktioniert auch immer nach den oben genannten Prinzipien: Das erste Argument ist ein Dataframe. Die nachfolgenden Argumente beschreiben, was mit dem Dataframe geschehen soll, wobei die Variablennamen (ohne Anführungszeichen) verwendet werden. Das Ergebnis ist ein neuer Dataframe Wir werden hier erstmal nur die basis dplyr-Funktionen besprechen. Aber auch alle anderen Befehle lassen sich in eine “Pipeline” integrieren. Hier mal ein sehr fortgeschrittenes Beispiel, wie das aussehen kann: # df_clean %&gt;% group_by(N,K,Retrievals) %&gt;% # summarise(corA = cor(mu_est_a, mu_real_a), # corC = cor(mu_est_c, mu_real_c)) %&gt;% # mutate(z_a = fisherz(corA), z_c = fisherz(corC)) %&gt;% # filter(Retrievals== 100) %&gt;% # group_by(N,K) %&gt;% # summarise(mean_a_100 = mean(z_a), # mean_c_100 = mean(z_c), # range_cor = range(mean_a_100), # range_cor = range(mean_a_100)) %&gt;% # mutate(meanCorA_100 = fisherz2r(mean_a_100), # meanCorC_100 = fisherz2r(mean_c_100)) %&gt;% # select(-c(mean_a_100, mean_c_100)) 5.5 Beispiel Stellt euch vor, ihr wollte gerne den Mittelwert des Alters der Helden aus dem Starwars Datensatz berechnen, und das für unterschiedliche Heimatwelten und Spezies: # Dazu benutzen wir den Piping Operator %&gt;%, um die Befehle zu verketten: starwars %&gt;% group_by(species, homeworld) %&gt;% summarise(mean_Age=mean(Age)) ## `summarise()` has grouped output by &#39;species&#39;. You can override using the `.groups` argument. ## # A tibble: 58 × 3 ## # Groups: species [38] ## species homeworld mean_Age ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena Aleen Minor NA ## 2 Besalisk Ojom NA ## 3 Cerean Cerea 92 ## 4 Chagrian Champala NA ## 5 Clawdite Zolan NA ## 6 Droid Naboo 33 ## 7 Droid Tatooine NA ## 8 Droid &lt;NA&gt; NA ## 9 Dug Malastare NA ## 10 Ewok Endor 8 ## # … with 48 more rows Wir schreiben hier im Prinzip: Nehme den Datensatz starwars (1. Zuerst der Dataframe): `starwars %&gt;%` Gruppiere diesen nach Spezies und Heimatwelt (1. Verarbeitungsschritt): `group_by(species, homeworld) %&gt;%` Berechne dann für jede dieser Gruppen den Mittelwert für die Variable “Age” (2. Schritt): `summarise(meanAge=mean(Age)` Da wir nun den Piping Operator benutzen der vom Dataframe starwars ausgeht, müssen wir auch nicht mehr bei jedem Befehl den Datensatz angeben, es reicht dies am Anfang der “Pipeline” zu tun. Problem: Wir haben noch viele fehlende Beobachtungen. Diese müssen wir zunächst entfehrnen. Auch das können wir nun innerhalb der “Pipeline” tun. Dazu bietet R den Befehl drop_na() an. Dieser entfehrnt alle fehlenden Werte eines Datensatzes. Wir müssen diesen Befehl nun einfach an eine Stelle in der Pipe einfügen, an der es Sinn macht, die Fehlenden Werte zu entfehrnen: # Wo könnte das hier sein ? starwars %&gt;% drop_na() %&gt;% group_by(species, homeworld) %&gt;% summarise(mean_Age=mean(Age)) ## `summarise()` has grouped output by &#39;species&#39;. You can override using the `.groups` argument. ## # A tibble: 21 × 3 ## # Groups: species [11] ## species homeworld mean_Age ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Cerean Cerea 92 ## 2 Ewok Endor 8 ## 3 Gungan Naboo 52 ## 4 Human Alderaan 19 ## 5 Human Bespin 37 ## 6 Human Concord Dawn 66 ## 7 Human Corellia 25 ## 8 Human Haruun Kal 72 ## 9 Human Kamino 31.5 ## 10 Human Naboo 64 ## # … with 11 more rows Nun haben wir nach verschiedenen Gruppen die Altersmittelwerte, bereinigt von den fehlenden Werten. Und das mit nur 2 Zeilen Code :) 5.6 Übung 2 # 1.) Gruppiert die Daten nach der Haarfarbe und berechnet für alle vollständigen Werte den Mittelwert und die Standardabweichung für die Größe und das Gewicht. Benutzt dafür wie im vorigen Beispiel die summarise() Funktion. Mit dieser könnt ihr auch mehrere Variablen berechnen. Bindet auch den drop_na() ein. Am Ende sollte es keine NA-Werte mehr in der Ausgabe geben. starwars %&gt;% drop_na() %&gt;% group_by(hair_color) %&gt;% summarise(mean_Height = mean(height), sd_Height= sd(height), mean_Mass = mean(mass), sd_Mass = sd(mass)) ## # A tibble: 8 × 5 ## hair_color mean_Height sd_Height mean_Mass sd_Mass ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 auburn, white 182 NA 77 NA ## 2 black 177 7.46 71.1 14.2 ## 3 blond 180 11.3 80.5 4.95 ## 4 brown 164. 41.6 65.4 29.9 ## 5 brown, grey 178 NA 120 NA ## 6 grey 170 NA 75 NA ## 7 none 186. 9.50 86.2 24.3 ## 8 white 196. 3.54 81 1.41 5.7 Dplyr : Neue Variablen mit mutate() berechnen Der letzte wichtige Befehl in dplyr ist mutate() bzw. across(). Letztes mal haben wir in dem Beispiel der Matrix zwei Variablen miteinander kombiniert und daraus einen neue berechnet (Größe*5). Mit mutate() können wir eine Variable und mit across() gleich mehrere Variablen umformen, oder neu berechnen. Hier möchte ich es am Beispiel einer z-Tranformation erläutern. Diese werden wir mit dem Befehl scale() tun, der standardmäßig in R vorhanden ist. 5.8 Beispiel starwars %&gt;% select(height,mass) %&gt;% mutate(z_height = scale(height), z_mass = scale(mass)) %&gt;% drop_na() ## # A tibble: 59 × 4 ## height mass z_height[,1] z_mass[,1] ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 172 77 -0.0678 -0.120 ## 2 167 75 -0.212 -0.132 ## 3 96 32 -2.25 -0.385 ## 4 202 136 0.795 0.228 ## 5 150 49 -0.701 -0.285 ## 6 178 120 0.105 0.134 ## 7 165 75 -0.269 -0.132 ## 8 97 32 -2.22 -0.385 ## 9 183 84 0.249 -0.0786 ## 10 182 77 0.220 -0.120 ## # … with 49 more rows starwars %&gt;% select(height,mass) %&gt;% mutate(across(c(height,mass), list(z=scale))) %&gt;% drop_na() ## # A tibble: 59 × 4 ## height mass height_z[,1] mass_z[,1] ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 172 77 -0.0678 -0.120 ## 2 167 75 -0.212 -0.132 ## 3 96 32 -2.25 -0.385 ## 4 202 136 0.795 0.228 ## 5 150 49 -0.701 -0.285 ## 6 178 120 0.105 0.134 ## 7 165 75 -0.269 -0.132 ## 8 97 32 -2.22 -0.385 ## 9 183 84 0.249 -0.0786 ## 10 182 77 0.220 -0.120 ## # … with 49 more rows In diesem Beispiel haben wir zunächste nur height und mass mit dem select() Befehl ausgewählt, daher werden auch nur diese beiden Spalten am Ende der Pipline im Datensatz angezeigt. Dies kann hilfreich sein, wenn man einen Datensatz mit sehr vielen Variablen analysieren muss, von denen nur einige wenige interessant sind. Dies ist meiner Erfahrung nach zum Beispiel bei Fragebögen der Fall, die unterschiedliche Facetten erfassen. Der nächste Befehl mutate() besteht immer aus einer Operation, die mit einer Spalte im Datensatz durchgeführt wird. Im Beispiel oben fügen wir also die Spalten z_height und z_mass hinzu, die sich jeweils aus scale(SPALTENNAME) berechnen und die z-Werte der jeweiligen Variablen berechnen. Wir können auch anstatt die Variablen einzeln umzurechnen, den Befehl scale() direkt auf mehrere Spalten anwenden. Dazu können wir den across() Befehl verwenden. Hier müssen wir innerhalb von mutate() einfach mit across(c(SPALTE1, SPALTE2)) einen Vektor der gewünschten Spalten übergeben und dann die Funktion(en), welche auf die Spalten angewand werden soll. Dies muss dann so definiert werden: mutate(across(c(height,mass), list(z=scale))) Diese Schreibweise hat den Vorteil das ihr In der list() mehrere Befehle übergeben könnt Die Originalspalten beibehalten werden Ihr den neuen Spalten direkt einen Suffix geben könnt. Dieser wird automatisch als “_suffix” an die neue Variable angehängt. mutate(across(c(height,mass), list(z=scale))) würde also zusätzliche zu Spalte1 und Spalte2 noch Spalte1_z und Spalte2_z, die den z-Wert der jeweiligen Variablen 5.9 Aufgabe bis zum nächsten Mal Übersetzt diese Anweisungen in dplyr-Sprache: Dataframe starwars Gruppiert diesen nach Spezies Entfehrnt alle fehlenden Werte Fasst die Variablen Age und Height zu nur einem Mittelwert zusammen z-Transformiert die Mittelwerte beider Spalten. Befehle die Ihr dazu braucht: drop_na(), across() ,scale(), mutate(), group_by(), summarise(), mean() Wenn ihr es Richtig gemacht habt, sollte der Datensatz am Ende so aussehen: Zusatzaufgabe: Ihr könnt den summarise() Befehl auch mit across() umsetzen und automatisch einen Suffix für die zusammengefassten Variablen erstellen, hierdurch spart man sich einige Tipparbeit. Das Ergebnis ist das gleiche, nur mit unterschiedlichen Spaltenamen für die “mean” Variablen. starwars %&gt;% group_by(species) %&gt;% drop_na() %&gt;% summarise(mean_Age = mean(Age), mean_Height = mean(height)) %&gt;% mutate(mean_Age_z = scale(mean_Age), mean_Height_z = scale(mean_Height)) ## # A tibble: 11 × 5 ## species mean_Age mean_Height mean_Age_z[,1] mean_Height_z[,1] ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Cerean 92 198 0.622 0.561 ## 2 Ewok 8 88 -1.03 -2.66 ## 3 Gungan 52 196 -0.166 0.503 ## 4 Human 45.5 178 -0.293 -0.0239 ## 5 Kel Dor 22 188 -0.757 0.269 ## 6 Mirialan 49 168 -0.225 -0.317 ## 7 Mon Calamari 41 180 -0.382 0.0346 ## 8 Trandoshan 53 190 -0.146 0.327 ## 9 Twi&#39;lek 48 178 -0.245 -0.0239 ## 10 Wookiee 200 228 2.75 1.44 ## 11 Zabrak 54 175 -0.126 -0.112 # mit across() starwars %&gt;% group_by(species) %&gt;% drop_na() %&gt;% summarise(across(c(Age, height), list(mean= mean))) %&gt;% mutate(across(c(Age_mean, height_mean), list(z=scale))) ## # A tibble: 11 × 5 ## species Age_mean height_mean Age_mean_z[,1] height_mean_z[,1] ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Cerean 92 198 0.622 0.561 ## 2 Ewok 8 88 -1.03 -2.66 ## 3 Gungan 52 196 -0.166 0.503 ## 4 Human 45.5 178 -0.293 -0.0239 ## 5 Kel Dor 22 188 -0.757 0.269 ## 6 Mirialan 49 168 -0.225 -0.317 ## 7 Mon Calamari 41 180 -0.382 0.0346 ## 8 Trandoshan 53 190 -0.146 0.327 ## 9 Twi&#39;lek 48 178 -0.245 -0.0239 ## 10 Wookiee 200 228 2.75 1.44 ## 11 Zabrak 54 175 -0.126 -0.112 "],["graphiken-mit-ggplot2.html", "6 Graphiken mit ggplot2 6.1 Exkurs: Warum viridis? 6.2 ggplot2 - Einführung 6.3 Vor der Visualisierung: Die Daten 6.4 Ästhetische Mapping 6.5 Graphischen Funktionen 6.6 Sonstige Funktionalität 6.7 Facetten 6.8 Zwischenübungen 6.9 Aufgaben bis zum nächsten Mal", " 6 Graphiken mit ggplot2 6.1 Exkurs: Warum viridis? Das viridis Paket in R stellt eine Reihe an Colormaps bereit, die folgenden Anspruch an sich stellen: gute Lesbarkeit und Unterscheidbarkeit in Graphiken auch bei Farbenblindheit oder Farbsehschwäche bleibt bei Grauskala(-druck) erhalten Praktisch bedeutet das, die Farbkarten sind: farbenfroh: sie umspannen weite Teile der Farbpalette damit Unterschiede einfach zu erkennen sind einheitlich: Punkte nah beieinander haben ähnliche Farben und Punkte weit auseinander stark unterschiedliche Farben - und das möglichst konsistent über den gesamten Farbraum hinweg \\(\\rightarrow\\) ein fester Abstand wird also an verschiedenen Stellen im Farbraum als perzeptuell gleich wahrgenommen, dh. keine mal schnellen mal langsamen Farbton- oder Helligkeitsänderungen Gerade die Einheitlichkeit ist wichtig, sie sorgt dafür, dass keine Gebiete überbetont werden, während Kontrast an anderen Strellen nicht gegeben ist. Hier die viridis Farbskala oben und jet (langjährig die Standardfarben in Matlab) unten: Bei jet stechen besonders Gelb und Türkis heraus - in einer Graphik gibt das Artefakte durch die Darstellung, weil unauffällige Daten durch die Farbwahl auf einmal außergewöhnlich wirken. Außerdem werden an anderen Stellen Unterschiede in den Daten dadurch unterschlagen, dass in weiten Teilen des roten und blauen Spektrums in jet fast keine Farbstufen enthalten sind. viridis versucht dieses Problem zu beheben und wirkt homogen - ohne “Spitzen und Täler”. Zusätzlich muss berücksichtigt werden, dass Graphiken auch bei Grauskaladruck noch interpretierbar bleiben. Das macht eine Grauskala aus viridis und jet: Bei der oberen viridis Skala vermindert sich die Interpretierbarkeit nur minimal, während man bei der unteren Skala nicht mehr zwischen hohen und niedrigen Werten unterscheiden kann. Tatsächlich wirkt es so, als ob die mittleren Bereiche besonders auffällig wären - Bereiche die meistens um die 0 herum liegen! Im viridis Paket gibt es 8 Colormaps, aus denen man wählen kann und die alle diese Kriterien erfüllen: viridis_map source: viridis Dokumentation 6.2 ggplot2 - Einführung ggplot2 ist ein Paket zur graphischen Darstellung in R, das auf dem Buch “The Grammar of Graphics” von Leland Wilkinson basiert. Wie bei dplyr ist die Codestruktur an Grammatik orientiert und somit einfach nachzuvollziehen. Ablauf der Graphikerstellung in ggplot2 lässt sich wie folgend zusammenfassen: Daten bereitstellen Wie werden Variablen in der Graphik in Ästhetik umgewandelt? - aesthetics() Was ist die x-Achse, was die y-Achse? Wonach wird farbkodiert? … Welche graphische Darstellung? Scatterplot - geom_point() Histogram - geom_histogram() Linienplot - geom_line() … Ggf. weitere Details definieren, wie zB die Achsenlabel Um eine Graphik zu “bauen” kann man also dieser Struktur folgen: ggplot(data = DATA, aes(MAPPINGS)) + GEOM_FUNCTION (mapping = aes(MAPPINGS), position = POSITION) + LABEL_FUNCTION + THEME_FUNCTION + COORDINATE_FUNCTION + SCALE_FUNCTION + FACET_FUNCTION Dabei sind DATA, MAPPINGS und GEOM_FUNCTION notwendig, während der Rest nicht notwendig ist, da es gute Standardeinstellungen gibt. Vorsicht: In ggplot2 sind Lagen mit + verknüpft und nicht mit %&gt;%! source: ggplot2 Cheat Sheet 6.3 Vor der Visualisierung: Die Daten Wir arbeiten mit einem Datensatz, der die Superhelden von Marvel und DC miteinander vergleicht. Die Daten finden sich auf GitHub (“https://github.com/cosmoduende/r-marvel-vs-dc”), sind aber auf zwei Files aufgeteilt, die wir erst einzeln laden und dann zusammenführen müssen. Um eine Vorlage zu geben, ist der Code dafür hier aufgenommen, ist aber zu fortgeschritten für den meisten Gebrauch, und kann für dieses Kapitel auch ignoriert werden. Erst werden die zwei Files von GitHub heruntergeladen und den Variablen MarvelCharacters und MarvelStats zugewiesen. Dabei werden fehlende Werte als NA kodiert: MarvelCharacters &lt;- read_csv(&quot;https://raw.github.com/cosmoduende/r-marvel-vs-dc/main/dataset_shdb/heroesInformation.csv&quot;, na = c(&quot;-&quot;, &quot;-99.0&quot;)) MarvelStats &lt;- read_csv(&quot;https://raw.github.com/cosmoduende/r-marvel-vs-dc/main/dataset_shdb/charactersStats.csv&quot;) Wir wählen nur die Charaktere aus Marvel und DC aus und machen ein bisschen weiteres preprocessing: marvelDcInfo &lt;- MarvelCharacters %&gt;% rename(Name = name) %&gt;% # `name` soll `Name` heißen filter(Publisher == &quot;Marvel Comics&quot; | # wir wählen nur Charaktere von Marvel oder... Publisher == &quot;DC Comics&quot;) %&gt;% # ...von DC filter(!duplicated(Name)) %&gt;% # alle Duplikate löschen wir select(Name, Gender, Race, Publisher, Weight, Height) # wir wollen nur bestimmte Spalten Dann fügen wir die Datensätze zusammen: MarvelDC &lt;- inner_join(marvelDcInfo, MarvelStats, by = &quot;Name&quot;) MarvelDC&lt;- MarvelDC %&gt;% # einige Zeilen sind falsch kodiert und enthalten eine andere Skala, # deswegen schließen wir alle Zeilen mit Intelligence = 1 aus. filter(Intelligence &gt; 1) Damit haben wir einen Datensatz MarvelDCmit dem wir weiterarbeiten können! Um ggplot Daten zu geben können wir sie entweder in den Klammern definieren: ggplot(data = MarvelDC) # Info: das &quot;data = &quot; kann auch weggelassen werden. Oder man gibt sie via Pipeline an ggplot weiter - beides ist äquivalent: MarvelDC %&gt;% ggplot() Dieser Code funktioniert allerdings noch nicht, da wir nur die Daten haben, aber noch keine MAPPINGS und auch keine GEOM_FUNCTION - die beiden anderen erforderlichen Angaben. 6.4 Ästhetische Mapping Das ästhetische Mapping (aesthetics) kann entweder direkt in ggplot definiert werden, dann gilt es für alle weiteren Schritte, oder es kann in der jeweiligen graphischen Funktion definiert werden, dann gilt es nur für diese geom_* Funktion. aesthetics Bedeutung x Welche Variable soll auf die x-Achse? y Welche Variable soll auf die y-Achse? shape Nach den Werten welcher Variable soll die Form vergeben werden? color Nach den Werten welcher Variable soll die Farbe vergeben werden? fill Nach den Werten welcher Variable soll die Füllfarbe vergeben werden? aesthetics in ggplot() werden an alle geom_* weitergegeben. aesthetics in geom_* sind spezifisch für diese graphische Funktion (und können geerbte Werte überschreiben). Hier ein Beispiel, das sich wie folgend liest: “Nehme MarvelDC als Daten. Die x-Achse soll Publisher sein und die y-Achse Combat. Stelle das in einem Boxplot dar.” ggplot(data = MarvelDC, aes(x = Publisher, y = Combat)) + geom_boxplot() Um eine farbliche Trennung nach Geschlecht zu haben, erweitern wir das Beispiel: “Nehme MarvelDC als Daten. Die x-Achse soll Publisher sein und die y-Achse Combat. Stelle das in einem Boxplot dar. Wähle unterschiedliche Farben für Gender und fülle die Plots damit.” ggplot(data = MarvelDC, aes(x = Publisher, y = Combat)) + geom_boxplot(aes(fill = Gender)) 6.5 Graphischen Funktionen Mit den graphischen Funktionen (geom_*) gibt man an, welche Art der graphischen Darstellung man will. Beispiele sind: aesthetics Anzahl Variablen: x ist dabei: y ist dabei: geom_bar() 1 diskret - geom_histogram() 1 kontinuierlich - geom_qq() 1 kontinuierlich - geom_boxplot() 2 diskret kontinuierlich geom_violin() 2 diskret kontinuierlich geom_point() 2 kontinuierlich kontinuierlich geom_smooth() 2 kontinuierlich kontinuierlich source: ggplot2 Cheat Sheet 6.5.1 Säulen- und Balkendiagramm geom_bar ist eine graphische Funktion um Häufigkeiten einer diskreten Variable in einem Säulen- oder Balkendiagramm zu visualisieren. ggplot(data = MarvelDC, # Nehme Daten MarcelDC aes(x = Publisher)) + # auf der x-Achse soll Publisher sein geom_bar() # stelle in einem Barplot dar Marvel hat doppelt soviele Superhelden wie DC! Wollen wir wissen, wie viele es genau sind, können wir mithilfe eines Graphik-Labels die Zählung hinzufügen: ggplot(data = MarvelDC, aes(x = Publisher)) + geom_bar() + geom_label(stat = &quot;count&quot;, # vergebe Label mithilfe der Statistik &quot;zählen&quot; aes(label = ..count..)) Indem wir eine Farbkodierung vergeben, können wir in diesem Säulendiagramm das Geschlechterverhältnis beurteilen. Da hier mit Farben gefüllt wird, ist das Argument fill. ggplot(data = MarvelDC, aes(x = Publisher, fill = Gender)) + # vergebe Füllfarbe nach Geschlecht geom_bar() In der Graphik oben haben wir den default-Parameter für Position verwendet, weil wir nichts anderes definiert haben. Das ist stack. Bei stackwerden die Teile übereinander “gestapelt” dargestellt. Da weit mehr Charaktere aus Marvel stammen, kann die Position fill dafür sorgen, dass wir das Geschlechterverhältnis besser beurteilen können. fill erstellt Balken gleicher Länge, sodass eine Beurteilung der relativen Anteile leichter fällt. Erst nehmen wir allerdings die NA Fälle heraus, damit wir bei Marvel und DC je nur zwei Kategorien haben. MarvelDC %&gt;% filter(!is.na(Gender)) %&gt;% # Schließe Gender=NA aus ggplot(aes(x = Publisher, fill = Gender)) + geom_bar(position = &quot;fill&quot;) # mache alle Balken gleich lang Die x oder y Angabe entscheidet darüber, ob ein Säulen- oder Balkendiagramm entsteht. Oben haben wir die Daten als x an die Funktion gegeben und ein Säulendiagramm erhalten. Geben wir die Daten als y weiter, erhalten wir ein Balkendiagramm: MarvelDC %&gt;% filter(!is.na(Gender)) %&gt;% ggplot(aes(y = Publisher, # auf der y-Achse soll Publisher sein fill = Gender)) + geom_bar(position = &quot;fill&quot;) Dieselbe Information können wir auch in Kreisform darstellen, in sogenannten Polarkoordinaten: MarvelDC %&gt;% filter(!is.na(Gender)) %&gt;% ggplot(aes(y = Publisher, fill = Gender)) + geom_bar(position = &quot;fill&quot;) + coord_polar() # stelle das in Polarkoordinaten dar Hier sieht man, dass bei DC Comics weniger als ein Viertel aller Helden weiblich sind, während es bei Marvel etwas mehr als ein Viertel sind. 6.5.2 Histogramm geom_histogram ist eine graphische Funktion um Häufigkeiten einer kontinuierlichen Variable zu visualisieren. Beispielsweise können wir schauen, wie schnell die Superhelden unterwegs sind: ggplot(MarvelDC, aes(x = Speed)) + # auf der x-Achse soll Speed sein geom_histogram( # stelle das in einem Histogramm dar bins = 10) # Anzahl der Kategorien soll 10 sein Unterscheidet sich die Geschwindigkeit der Helden zwischen Marvel und DC? ggplot(MarvelDC, aes(x = Speed, fill = Publisher)) + geom_histogram(bins = 10, alpha = 0.7, # &quot;Durchsichtigkeit&quot; bei 70% position = &quot;dodge&quot;) # Position Balken: nebeneinander Offensichtlich nicht, die Verteilungen sind sich relativ ähnlich. Bei Speed fällt uns allerdings direkt auf, dass es nicht sehr normalverteilt aussieht. Ein Histogramm lässt hier einen ersten Eindruck zu, aber eine visuelle Prüfung der Normalverteilung sollten wir lieber über einen qq-Plot vornehmen. 6.5.3 QQ-Plot Also erstellen wir einen qq-Plot von Speed, sowohl mit Punkten als auch mit Vergleichslinie: ggplot(MarvelDC, aes(sample = Speed)) + # erstelle Quantile von: Speed geom_qq() + # erstelle QQ-Plot Punkte geom_qq_line() # erstelle QQ-Plot Vergleichslinie Bei Speed zeigen sich deutliche Abweichungen von einer Normalverteilung. Diese Variable ist nicht normalverteilt. Das gilt auch für alle anderen Eigenschaften (hier nicht gezeigt). Nur der Summenscore, Total, zeigt im qq-Plot eine Verteilung nahe der Normalverteilung: ggplot(MarvelDC, aes(sample = Total)) + # erstelle Quantile von: Total geom_qq() + geom_qq_line() 6.5.4 Boxplot geom_boxplotist eine graphische Funktion um kontinuierliche Verteilungen getrennt nach einer diskreten Gruppierung darzustellen. Die Frage, die wir beantworten wollen lautet: Hat Marvel oder DC die stärkeren Superhelden? - Dafür betrachten wir den Total Wert jedes Helden. ggplot(MarvelDC, aes(x = Publisher, y = Total)) + geom_boxplot() Auf den ersten Blick mithilfe eines Boxplots gibt es keine Unterschiede zwischen Marvel Comics und DC Comics. ggplot(MarvelDC, aes(x = Publisher, y = Total, fill= Gender)) + geom_boxplot() Betrachten wir Total aufgespalten nach Geschlecht, so scheint Marvel etwas stärkere Männer und schwächere Frauen zu haben - allerdings sind die Unterschiede so gering, dass es sich wahrscheinlich um zufällige Schwankungen und nicht um belastbare Effekte handelt! Wir gehen also davon aus, dass keins der Universen dem anderen überlegen ist. 6.5.5 Violinen-Plot geom_violin ist ebenfalls eine graphische Funktion um kontinuierliche Verteilungen getrennt nach einer diskreten Gruppierung darzustellen - und lässt etwas mehr Aufschluss auf die Daten zu (zB wie die grobe Verteilung der Werte ist). ggplot(MarvelDC, aes(x = Publisher, y = Total, fill= Gender)) + geom_violin( # stelle in einem Violinenplot dar trim=FALSE) # schneide Spitzen nicht ab 6.5.6 Beeswarm Plot mit dem Paket ggbeeswarm Das package ggbeeswarm bietet eine ähnliche Darstellung durch die graphische Funktion geom_quasirandom: library(ggbeeswarm) MarvelDC %&gt;% filter(!is.na(Gender)) %&gt;% ggplot(aes(y = Total, x = Publisher, colour = Gender)) + geom_quasirandom(dodge.width = 1) # stelle das als beeswarm dar Weder Violinen-Plot noch Beeswarm-Plot deuten darauf hin, dass Marvels Superhelden stärker und cooler sind, als die von DC. Wir müssen also weiterhin bei der Annahme bleiben, dass beide Universen gleich gut sind. 6.5.7 Scatterplot Ein Scatterplot mit geom_point stellt die Daten als Punkte im Raum zweier kontinuierlicher Variablen dar. Beispielsweise können wir Power und Durability aller Helden gegeneinander darstellen: ggplot(data = MarvelDC, aes(x = Power, y = Durability)) + geom_point() # stelle als Scatterplot dar Auch diese Graphik können wir einfach nach Publisher farblich kodieren. Hier sollen die Punkte Farbe haben, aber es wird nichts mit Farbe gefüllt, deswegen ist das Argument hier color: ggplot(data = MarvelDC, aes(x = Power, y = Durability, color = Publisher)) + # getrennte Farben für Publisher geom_point() Die Daten beider Publishersind weit verteilt, es ist also keineswegs so, dass DCs Superhelden weniger Powerhaben, als die von Marvel. Wollen wir zusätzlich nach Geschlecht unterscheiden, so geht das beispielsweise über die Form der Punkte mithilfe des Arguments shape: ggplot(data = MarvelDC, aes(x = Power, y = Durability, color = Publisher, shape = Gender)) + # getrennte Formen für Gender geom_point() 6.5.8 (Linearer) Fit Die Power und DurabilityDaten können wir mit einer Funktion fitten. Damit können wir visuell prüfen, ob es bei Marvel und DC einen anderen Zusammenhang zwischen Powerund Durabilitygibt. Dafür verwendet man die graphischen Funktion geom_smooth. Um ein lineares Modell zu erhalten, müssen wir das Argument method = \"lm\" für “linear model” setzen. Um y durch x vorherzusagen, brauchen wir die Formel y ~ x: ggplot(data = MarvelDC, aes(x = Power, y = Durability, color = Publisher, shape = Gender)) + geom_point() + geom_smooth(method = &quot;lm&quot;, # lineares Modell formula = &#39;y ~ x&#39;, # y sagen wir durch x vorher se = FALSE) # keine Fehlerbalken Jetzt haben wir aber 5 Fits! Je für Geschlecht und Publisher - nicht nur für die beiden Publisher wie wir wollten! Das liegt daran, dass wir sowohl Farbe als auch Form innerhalb von ggplotbei den allgemeinen aesthetics definiert haben. Um nur einen linearen Fit für jeden Publisher zu erhalten, nicht aber nach Geschlecht aufgespalten, müssen wir die Form-Kennung für Geschlecht nur an geom_point geben. Auf diese Weise kann sie nicht mehr an geom_smooth weitergegeben werden. Die Farb-Kennung für Publisher geben wir nur an die Linien, also nur an geom_smooth. Mit se=TRUE erstellen wir zusätzlich Fehlerintervalle um die linearen Fit-Funktionen herum. So erhalten wir einen linearen Fit der Power und Durabilityder Superhelden farblich getrennt nach Marvel und DC: ggplot(data = MarvelDC, aes(x = Power, y = Durability)) + geom_point(aes(shape = Gender)) + # Trennung gilt nur für Punkte geom_smooth(aes(color = Publisher), method = &quot;lm&quot;, formula = &#39;y ~ x&#39;, se = TRUE) Auch hier zeigen sich weiterhin keine Unterschiede zwischen den Publishern. Wir müssen wohl endgültig annehmen, dass Mavel nicht das alleinige Recht auf coole Superhelden hat. 6.5.9 Linienplot Um Linienplots zu veranschaulichen, wählen wir eine übersichtliche Menge an Datenpunkten aus, zB einige der X-Men. Die Datenpunkte trennen wir farblich nach Geschlecht und verbinden alle Punkte durch eine Linie. # Erstelle Vektor der X-Men Charaktere: XMen &lt;- c(&quot;Wolverine&quot;, &quot;Jean Grey&quot;, &quot;Storm&quot;, &quot;Beast&quot;, &quot;Cyclops&quot;, &quot;Professor X&quot;, &quot;Raven&quot;) MarvelDC %&gt;% filter(Name %in% XMen) %&gt;% # Verwende nur X-Men ggplot(aes(x = Power, y = Durability)) + geom_point( # stelle in Scatterplot dar aes(color = Gender), # vergebe Farbe der Punkte nach Gender size = 3) + # Punkte sollen Größe 3 haben geom_line() # verbinde Punkte mit Linie Da wir die Farbe innerhalb von geom_point definiert haben, haben wir in den allgemeinen aestheticskeine Gruppierung enthalten. Deswegen verbindet die Linie einfach alle Datenpunkte. Informativer ist es natürlich, wenn wir getrennte Linien für die Geschlechter haben, das erreichen wir, indem wir die Farbdefinition in den allgemeinen aestheticsdurchführen und nicht innerhalb von geom_point: XMen &lt;- c(&quot;Wolverine&quot;, &quot;Jean Grey&quot;, &quot;Storm&quot;, &quot;Beast&quot;, &quot;Cyclops&quot;, &quot;Professor X&quot;, &quot;Raven&quot;) MarvelDC %&gt;% filter(Name %in% XMen) %&gt;% ggplot(aes(x = Power, y = Durability, color = Gender)) + # Farbe nach Gender (Punkte &amp; Linie) geom_point(size = 3) + geom_line(aes(linetype = Gender)) # zusätzlich unterschiedliche Linen nach Gender Wollen wir ablesen, welcher Charakter welche Werte aufweist, können wir mit geom_labelTextlabels zu unserem Plot hinzufügen. Außerdem skalieren wir die Achsen so, dass wir den absoluten Null Punkt sehen und beide Achsen symmetrisch laufen. XMen &lt;- c(&quot;Wolverine&quot;, &quot;Jean Grey&quot;, &quot;Storm&quot;, &quot;Beast&quot;, &quot;Cyclops&quot;, &quot;Professor X&quot;, &quot;Raven&quot;) MarvelDC %&gt;% filter(Name %in% XMen) %&gt;% ggplot(aes(x = Power, y = Durability, color = Gender)) + geom_point(size = 3) + geom_line(aes(linetype = Gender)) + geom_label(aes(label = Name, # Füge Label hinzu mit: &quot;Name&quot; color = Gender)) + # färbe Labels nach Geschlecht xlim(c(0, 110))+ # x-Achse soll laufen von 0-110 ylim(c(0, 110)) # y-Achse soll laufen von 0-110 6.6 Sonstige Funktionalität 6.6.1 Labels Label sind die wahrscheilich wichtigste zusätzliche Funktionalität, die fast immer benötigt wird um einen Plot allgemein verständlich zu machen. Mithilfe von labs() können Titel, Untertitel, Achsenbeschriftungen und eine Caption zu einem Plot hinzugefügt werden. zB für den Plot der X-Men: XMen &lt;- c(&quot;Wolverine&quot;, &quot;Jean Grey&quot;, &quot;Storm&quot;, &quot;Beast&quot;, &quot;Cyclops&quot;, &quot;Professor X&quot;, &quot;Raven&quot;) MarvelDC %&gt;% filter(Name %in% XMen) %&gt;% ggplot(aes(x = Power, y = Durability, color = Gender)) + geom_point(size = 3) + geom_line(aes(linetype = Gender)) + geom_label(aes(label = Name, color = Gender)) + xlim(c(0, 110)) + ylim(c(0, 110)) + # Füge Beschriftungen hinzu: Titel, x- &amp; y-Achsen, Caption labs(title = &quot;Power and durability of the X-Men&quot;, x = &quot;Power&quot;, y = &quot;Durability&quot;, caption = &quot;dataset source: https://github.com/cosmoduende/r-marvel-vs-dc&quot; ) Ein weiteres Beispiel: ggplot(MarvelDC, aes(x = Publisher, y = Total, fill= Gender)) + geom_boxplot() + labs(title = &quot;Total skills of Marvel and DC superheros&quot;, subtitle = &quot;Separate for their gender&quot;, x = &quot;Publisher&quot;, y = &quot;Total skills&quot;, caption = &quot;dataset source: https://github.com/cosmoduende/r-marvel-vs-dc&quot; ) 6.6.2 Thema Es gibt verschiedene themes die das grundlegende Graphiklayout bestimmen. theme_bw() - weißer Hintergrund mit grid Linien theme_gray() - grauer Hintergrund mit hellen grid Linien (default) theme_dark() - dunkler Hintergrund mit grid Linien theme_minimal() - minimales theme theme_void() - leeres theme Minimalistisches Thema: ggplot(MarvelDC, aes(x = Publisher, y = Total, fill= Gender)) + geom_boxplot() + theme_minimal() # verwende Thema: Minimal Dunkles Thema: ggplot(MarvelDC, aes(x = Publisher, y = Total, fill= Gender)) + geom_boxplot() + theme_dark() # verwende Thema: Dunkel 6.6.3 Position Mit position kann die Positionierung graphischer Elemente zueinander eingestellt werden. Positionsarten sind zB: identity - wahre Werte an wahrer Position, hier kann man Plots zB durch den alpha Parameter entzerren stack - Elemente aufeinander schichten (default) dodge - Elemente nebeneinander zeigen jitter - Zufälliges Rauschen auf die (x,y) Positions jedes Elements addieren um den Plot zu entzerren dodge = nebeneinander: MarvelDC %&gt;% filter(!is.na(Alignment), # verwende nur Alignment Alignment != &quot;neutral&quot;) %&gt;% # good and bad ggplot(aes(x = Intelligence, fill = Alignment)) + geom_histogram(bins = 15, alpha = 0.6, position = &quot;dodge&quot;) # Position: nebeneinander stack = aufeinander: MarvelDC %&gt;% filter(!is.na(Alignment), Alignment != &quot;neutral&quot;) %&gt;% ggplot(aes(x = Intelligence, fill = Alignment)) + geom_histogram(bins = 15, alpha = 0.6, position = &quot;stack&quot;) # Position: aufeinander identity = hintereinander: MarvelDC %&gt;% filter(!is.na(Alignment), Alignment != &quot;neutral&quot;) %&gt;% ggplot(aes(x = Intelligence, fill = Alignment)) + geom_histogram(bins = 15, alpha = 0.6, position = &quot;identity&quot;) # Position: hintereinander 6.6.4 Legenden Die Legende wird von ggplot automatisch erstellt und kann einfach an die Positionen bottom, right, left und top gelegt werden: ggplot(MarvelDC, aes(x = Publisher, y = Total, fill= Gender)) + geom_boxplot() + theme_minimal() + labs(title = &quot;Total skills of Marvel and DC superheros&quot;, subtitle = &quot;Separate for their gender&quot;, x = &quot;Publisher&quot;, y = &quot;Total skills&quot;, caption = &quot;dataset source: https://github.com/cosmoduende/r-marvel-vs-dc&quot; ) + theme(legend.position=&quot;top&quot;) # positioniere Legende oben 6.6.5 Koordinatensysteme Das wichtigste Koordinatensystem ist zweifellos das kartesische. In R kann man aber zB auch Polarkoordinaten verwenden, oder das kartesische System “drehen” coord_flip - dreht ein kartesisches Koordinatensystem um (x wird zu y und umgekehrt) - empfohlen ist allerdings, das über die Definition von x und y direkt zu lösen. coord_polar - Polarkoordinaten Polarkoordinaten haben wir vorne beim Balkendiagramm schon gesehen. 6.6.6 Farbskalen scale bestimmt auf welche Farbskala die Daten abgebildet werden. Am Beispiel von viridis: scale_color_viridis_d() - diskretes viridis Spektrum für das Argument color scale_color_viridis_c() - kontinuierliches viridis Spektrum für das Argument color scale_fill_viridis_d() - diskretes viridis Spektrum für das Argument fill Über option kann im Paket viridis auf eine andere der enthaltenen Skalen zugegriffen werden: scale_fill_viridis_d(option=inferno) - diskretes inferno Spektrum für das Argument fill Neben dem viridis Package gibt es auch den ColorBrewer in R, der unter anderem folgende Farbkarten kennt (am Beispiel von fill Skalen): scale_fill_brewer(palette=\"Set1\") andere mögliche Einstellungen für palette: \"Set2\", \"Set3\", \"Accent\", \"Dark2\", \"Pastel1\", \"Pastel2\" Wenn man allerdings schon ein Farbspektrum selbst definiert, ist es empfehlenswert ein colorblind friendly Schema wie alle Skalen aus dem viridis Package zu benutzen. Im folgenden Beispiel erstellen wir eine Liste der besten Superhelden der X-Men, der Avengers und der Guardians of the Galaxy. Dann veranschaulichen wir in einem Balkendiagramm welcher Art sie angehören. Also ob es Menschen sind, oder Mutanten, oder Androiden. # Charaktere der X-Men, der Guardians of the Galaxy und der Avengers XMen &lt;- c(&quot;Wolverine&quot;, &quot;Jean Grey&quot;, &quot;Storm&quot;, &quot;Beast&quot;, &quot;Cyclops&quot;, &quot;Professor X&quot;, &quot;Raven&quot;) GoG &lt;- c(&quot;Groot&quot;, &quot;Quill&quot;, &quot;Rocket Raccoon&quot;) Avengers &lt;- c(&quot;Iron Man&quot;, &quot;Captain America&quot;, &quot;Black Widow&quot;, &quot;Hulk&quot;, &quot;Hawkeye&quot;, &quot;Thor&quot;, &quot;Spiderman&quot;, &quot;Vision&quot;) # ein Vektor mit den coolsten Superhelden BestHeros &lt;- c(XMen, GoG, Avengers) MarvelDC %&gt;% filter(Name %in% BestHeros) %&gt;% # Nur Charaktere aus &#39;BestHeros&#39; ggplot(aes(y = Race, # y soll &#39;Race&#39; sein fill= Race)) + # vergebe Füllfarbe nach &#39;Race&#39; geom_bar() + # stelle als Balken dar theme_bw() + # in scharz-weißem Thema # Beschrifte labs(title = &quot;Races of superheros&quot;, subtitle = &quot;X-Men, Avengers and Guardians of the Galaxy&quot;, x = &quot;Count&quot;, y = &quot;&quot;, caption = &quot;dataset source: https://github.com/cosmoduende/r-marvel-vs-dc&quot; ) + scale_fill_viridis_d() # verwende Farben aus viridis 6.6.7 Variablenskalen Mit ggplot2 können Variablen einfach auf unterschiedliche Skalen übertragen werden. Diese Funktionalität kann mit x oder y verwendet werden, zB: scale_x_log10() scale_x_sqrt() scale_x_reverse() 6.7 Facetten Facettierung bedeutet, dass ein Plot in mehrere Plots aufgeteilt wird, abhängig von den Werten einer oder mehrerer diskreter Variablen. Der einfachste Weg geht über facet_wrap(). zB erweitern wir das Balkendiagramm von oben, welches uns die Art der Superhelden zeigt, um die größten Gegner dieser Helden. Nachdem wir einen Vektor erstellt haben, in dem unsere größten Helden und Bösewichte sind, facettieren wir nach Alignment, dh wir erstellen unterschiedliche Grids für die Guten und die Bösen: # Gegner der X-Men, der Guardians of the Galaxy und der Avengers VXMen &lt;- c(&quot;Magneto&quot;, &quot;Gambit&quot;, &quot;Apocalypse&quot;, &quot;Mystique&quot;) VGoG &lt;- c(&quot;Ronin&quot;, &quot;Thanos&quot;) VAvengers &lt;- c(&quot;Loki&quot;, &quot;Ultron&quot;, &quot;Doctor Doom&quot;, &quot;Galactus&quot;) # ein Vektor mit den coolsten Superhelden und ihren größten Gegnern HerosVillains &lt;- c(BestHeros, VXMen, VGoG, VAvengers) MarvelDC %&gt;% filter(Name %in% HerosVillains) %&gt;% # Nur wenn in &#39;HerosVillains&#39; ggplot(aes(y = Race, # y soll &#39;Race&#39; sein fill= Race)) + # vergebe Füllfarbe nach &#39;Race&#39; geom_bar() + # stelle als Balken dar theme_bw() + # in scharz-weißem Thema # Beschrifte labs(title = &quot;Races of superheros and their villains&quot;, subtitle = &quot;X-Men, Avengers and Guardians of the Galaxy&quot;, x = &quot;Count&quot;, y = &quot;&quot;, caption = &quot;dataset source: https://github.com/cosmoduende/r-marvel-vs-dc&quot; ) + scale_fill_viridis_d() + # verwende Farben aus viridis facet_wrap(~ Alignment) # trenne Grids nach &#39;Alignment&#39; Damit haben ein eine vollständigen, beschrifteten und hübschen Plot 6.8 Zwischenübungen Welches Universum hat mehr Helden, welches mehr Bösewichte? Veranschauliche die Verhältnisse. Unterscheidet sich die Verteilung von Intelligenz zwischen Helden und Bösewichten? Stelle in einem Histogramm dar. Stelle die Intelligenz getrennt nach Helden und Bösewichten in einem Violinenplot dar. 6.8.1 Lösung Zwischenübungen Welches Universum hat mehr Helden, welches mehr Bösewichte? Veranschauliche die Verhältnisse. MarvelDC %&gt;% ggplot(aes(y = Publisher, fill = Alignment)) + geom_bar(position = &quot;fill&quot;) Unterscheidet sich die Verteilung von Intelligenz zwischen Helden und Bösewichten? Stelle in einem Histogramm dar. MarvelDC %&gt;% filter(!is.na(Alignment), Alignment != &quot;neutral&quot;) %&gt;% ggplot(aes(x = Intelligence, fill = Alignment)) + geom_histogram(bins = 15, position = &quot;dodge&quot;, alpha = 0.6) Stelle die Intelligenz getrennt nach Helden und Bösewichten in einem Violinenplot dar. MarvelDC %&gt;% filter(!is.na(Alignment), Alignment != &quot;neutral&quot;) %&gt;% ggplot(aes(x = Alignment, y = Intelligence, fill = Alignment)) + geom_violin(trim = FALSE, alpha = 0.2) 6.9 Aufgaben bis zum nächsten Mal Erstelle einen Barplot (geom_bar) mit vertikalen bars getrennt für die Geschlechter. Marvel und DC sollen durch Farben kodiert sein. Erstelle ein Histogramm von Durability. Wähle eine adäquate Anzahl an bins aus. Facettiere den Plot aus Aufgabe 2 nach Publisher. Beschrifte den Plot aus Aufgabe 3, wähle persönliche Einstellungen für: Farbskala Thema Legendenposition Zusatzaufgabe: Wähle einen adäquaten Plot um die folgende inhaltliche Frage zu beantworten. Gibt es bei Marvel Comics einen positiven Zusammenhang zwischen der Intelligenz und der totalen Superhelden-Kraft? - Google wie man auch den Regressionskoeffizienten im Plot angezeigt bekommt. 6.9.1 Lösung Aufgaben bis zum nächsten Mal Erstelle einen Barplot (geom_bar) mit vertikalen bars getrennt für die Geschlechter. Marvel und DC sollen soll durch Farben kodiert sein. MarvelDC %&gt;% ggplot(aes(x = Gender, fill = Publisher)) + geom_bar() Erstelle ein Histogramm von Durability. Wähle eine adäquate Anzahl an bins aus. MarvelDC %&gt;% ggplot(aes(x = Durability)) + geom_histogram(bins = 10) Facettiere den Plot aus Aufgabe 2 nach Publisher. MarvelDC %&gt;% ggplot(aes(x = Durability, fill = Publisher)) + geom_histogram(bins = 10) + facet_wrap(~ Publisher) Beschrifte den Plot aus Aufgabe 3, wähle persönliche Einstellungen für: Farbskala Thema Legendenposition Beispielsweise: MarvelDC %&gt;% ggplot(aes(x = Durability, fill = Publisher)) + geom_histogram(bins = 10) + facet_wrap(~ Publisher) + labs(title = &quot;The durability of superheros&quot;, subtitle = &quot;separate for Marvel Comics and DC Comics&quot;, x = &quot;Durability&quot;, y = &quot;Count&quot;, caption = &quot;dataset source: https://github.com/cosmoduende/r-marvel-vs-dc&quot; ) + theme_dark() + theme(legend.position = &quot;left&quot;) + scale_fill_viridis_d(option = &quot;inferno&quot;) Oder: MarvelDC %&gt;% ggplot(aes(x = Durability, fill = Publisher)) + geom_histogram(bins = 10) + facet_wrap(~ Publisher) + labs(title = &quot;The durability of superheros&quot;, subtitle = &quot;separate for Marvel Comics and DC Comics&quot;, x = &quot;Durability&quot;, y = &quot;Count&quot;, caption = &quot;dataset source: https://github.com/cosmoduende/r-marvel-vs-dc&quot; ) + theme_gray() + theme(legend.position = &quot;bottom&quot;) + scale_fill_brewer(palette = &quot;Set1&quot;) Zusatzaufgabe: Wähle einen adäquaten Plot um die folgende inhaltliche Frage zu beantworten. Gibt es bei Marvel Comics einen positiven Zusammenhang zwischen der Intelligenz und der totalen Superhelden-Kraft? - Google wie man auch den Regressionskoeffizienten im Plot angezeigt bekommt. # Paket um Korrelationskoeffizienten hinzuzufügen: library(ggpubr) MarvelDC %&gt;% filter(Publisher == &quot;Marvel Comics&quot;) %&gt;% # nur Marvel ggplot(aes(x = Intelligence, y = Total)) + # Intelligence gegen Total geom_point() + # stelle als Scatterplot dar geom_smooth(method = &quot;lm&quot;, # fitte lineares Modell... formula = &#39;y ~ x&#39;, # ...sage y duch x vorher... se = TRUE) + # ...und zeige SE-Intervall # um Korrelationskoeffizienten hinzuzufügen: stat_cor(method = &quot;pearson&quot;, label.x = 3, label.y = 550) Ja, es gibt einen positiven Zusammenhang (r= 0.52). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
